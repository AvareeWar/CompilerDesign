/*-------------------------------------------------------------------------*
 *---									---*
 *---		Node.h							---*
 *---									---*
 *---	    This file declares and defines the parse nodes used by the	---*
 *---	tiny pascal parser.						---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a		2017 June 2		Joseph Phillips	---*
 *---									---*
 *-------------------------------------------------------------------------*/

class		Node
{
  //  I.  Member vars:

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  Node&		operator=	(const Node&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To create a default Node.  No parameters.  No return value.
  Node				()
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  Node				(const Node&	rhs
				)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  virtual
  ~Node				()
				= 0;

  //  V.  Accessors:

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  virtual
  VariableMention*		compile
				(simpleType_ty&	simpleType
				)
				= 0;

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  virtual
  void		writeAssembly	(std::ostream&	output
				)
				= 0;

};


//  PURPOSE:  To represent the occurrence of a boolean constant in the Pascal
//	source code.
class		BooleanConstantNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the boolean constant.
  bool				boolConst_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	integer constant that '*this' represents.
  VariableMention*		varPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  BooleanConstantNode&
		operator=	(const BooleanConstantNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of booleab
  //	constant 'newBoolConst' in the Pascal source.  No return value.
  BooleanConstantNode		(bool	newBoolConst
				) :
				Node(),
				boolConst_(newBoolConst),
				varPtr_(NULL)
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  BooleanConstantNode		(const BooleanConstantNode&	rhs
				) :
				Node(rhs),
				boolConst_(rhs.getBoolConst()),
				varPtr_( (rhs.varPtr_ == NULL)
					 ? NULL
					 : new VariableMention(*rhs.varPtr_)
				       )
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~BooleanConstantNode		()
				{
				  delete(varPtr_);
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the integer constant.
  int		getBoolConst	()
				const
				{ return(boolConst_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  varPtr_	= new VariableMention;
				  simpleType	= BOOLEAN_ST;
				  return(varPtr_);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  output << "  load " << *varPtr_
					 << ","
					 << booleanConstName[getBoolConst()]
					 << std::endl;
				}

};


//  PURPOSE:  To represent the occurrence of an integer constant in the Pascal
//	source code.
class		IntegerConstantNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the integer constant.
  int				intConst_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	integer constant that '*this' represents.
  VariableMention*		varPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  IntegerConstantNode&
		operator=	(const IntegerConstantNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of integer
  //	constant 'newIntConst' in the Pascal source.  No return value.
  IntegerConstantNode		(int	newIntConst
				) :
				Node(),
				intConst_(newIntConst),
				varPtr_(NULL)
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  IntegerConstantNode		(const IntegerConstantNode&	rhs
				) :
				Node(rhs),
				intConst_(rhs.getIntConst()),
				varPtr_( (rhs.varPtr_ == NULL)
					 ? NULL
					 : new VariableMention(*rhs.varPtr_)
				       )
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~IntegerConstantNode		()
				{
				  delete(varPtr_);
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the integer constant.
  int		getIntConst	()
				const
				{ return(intConst_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  varPtr_	= new VariableMention;
				  simpleType	= INTEGER_ST;
				  return(varPtr_);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  output << "  load " << *varPtr_
					 << ","
					 << getIntConst() << std::endl;
				}

};


//  PURPOSE:  To represent the occurrence of an real constant in the Pascal
//	source code.
class		RealConstantNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the real constant.
  float				realConst_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	real constant that '*this' represents.
  VariableMention*		varPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  RealConstantNode&
		operator=	(const RealConstantNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of real
  //	constant 'newFloatConst' in the Pascal source.  No return value.
  RealConstantNode		(float	newRealConst
				) :
				Node(),
				realConst_(newRealConst),
				varPtr_(NULL)
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  RealConstantNode		(const RealConstantNode&	rhs
				) :
				Node(rhs),
				realConst_(rhs.getRealConst()),
				varPtr_( (rhs.varPtr_ == NULL)
					 ? NULL
					 : new VariableMention(*rhs.varPtr_)
				       )
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~RealConstantNode		()
				{
				  delete(varPtr_);
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the real constant.
  float		getRealConst	()
				const
				{ return(realConst_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  varPtr_	= new VariableMention;
				  simpleType	= REAL_ST;
				  return(varPtr_);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  output << "  load " << *varPtr_
					 << ","
					 << getRealConst() << std::endl;
				}

};


//  PURPOSE:  To represent the occurrence of a string constant in the Pascal
//	source code.
class		StringConstantNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the string constant.
  char*				charPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	string constant that '*this' represents.
  VariableMention*		varPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  StringConstantNode&
		operator=	(const StringConstantNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of string
  //	constant 'newCharPtr' in the Pascal source.  '*this' becomes the owner
  //	of the pointed-to memory.  No return value.
  StringConstantNode		(char*	newCharPtr
				) :
				Node(),
				charPtr_(newCharPtr),
				varPtr_(NULL)
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  StringConstantNode		(const StringConstantNode&	rhs
				) :
				Node(rhs),
				charPtr_(strdup(rhs.getCharPtr())),
				varPtr_( (rhs.varPtr_ == NULL)
					 ? NULL
					 : new VariableMention(*rhs.varPtr_)
				       )
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~StringConstantNode		()
				{
				  delete(varPtr_);
				  free(charPtr_);
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the string constant.
  const char*	getCharPtr	()
				const
				{ return(charPtr_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  varPtr_	= new VariableMention;
				  simpleType	= STRING_ST;
				  return(varPtr_);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  output << "  load " << *varPtr_
					 << ",\""
					 << getCharPtr()
					 << "\""
					 << std::endl;
				}

};


//  PURPOSE:  To represent the occurrence of a variable in the Pascal source
//	code.
class		VariableNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the name of the variable.
  std::string			name_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	integer constant that '*this' represents.
  VariableMention*		varPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  VariableNode&	operator=	(const VariableNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of a variable
  //	named 'newName' in the Pascal source.  No return value.
  VariableNode			(const std::string&	newName
				) :
				Node(),
				name_(newName),
				varPtr_(NULL)
				{ }

  //  PURPOSE:  To make '*this' Node a copy of 'rhs'.  No return value.
  VariableNode			(const VariableNode&	rhs
				) :
				Node(rhs),
				name_(rhs.getName()),
				varPtr_( (rhs.varPtr_ == NULL)
					 ? NULL
					 : new VariableMention(*rhs.varPtr_)
				       )
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~VariableNode			()
				{
				  delete(varPtr_);
				  varPtr_	= NULL;
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the address of the VariableMention that encodes
  //	'*this' Node.
  VariableMention*
		getVarPtr	()
				const
				{ return(varPtr_); }

  //  PURPOSE:  To return the VariableMention that encodes '*this' Node.
  VariableMention&
		getVar		()
				const
				{ return(*varPtr_); }

  //  PURPOSE:  To return the integer constant.
  const std::string&
		getName		()
				const
				{ return(name_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				);

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  //  NO CODE HERE!
				  //  LEAVE THIS EMPTY!
				}

};


//  PURPOSE:  To represent the occurrence of a binary logic operation in the
//	Pascal source code.
class		BinaryLogicOpNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the operation that '*this' node represents.
  binaryLogicOp_ty		binaryLogicOp_;

  //  PURPOSE:  To hold the address of the left-hand-side operand.
  Node*				lhsOperandPtr_;

  //  PURPOSE:  To hold the address of the right-hand-side operand.
  Node*				rhsOperandPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*lhsOperandPtr_'.
  VariableMention*		lhsVarPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*rhsOperandPtr_'.
  VariableMention*		rhsVarPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  BinaryLogicOpNode&
		operator=	(const BinaryLogicOpNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of the operation
  //	'newOp' operating on '*newLhsPtr' and '*newRhsPtr' in the Pascal
  //	source.  No return value.
  BinaryLogicOpNode		(binaryLogicOp_ty	newOp,
				 Node*			newLhsPtr,
  				 Node*			newRhsPtr
				) :
				Node(),
				binaryLogicOp_(newOp),
				lhsOperandPtr_(newLhsPtr),
				rhsOperandPtr_(newRhsPtr),
				lhsVarPtr_(NULL),
				rhsVarPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~BinaryLogicOpNode		()
				{
				  delete(rhsOperandPtr_);
				  delete(lhsOperandPtr_);
				  //  Do _not_ delete() 'rhsVarPtr_',
				  //    '*this' does not own it.
				  //  Do _not_ delete() 'lhsVarPtr_',
				  //    '*this' does not own it.
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the operation that '*this' node represents.  No
  //	parameters.
  binaryLogicOp_ty
		getBinaryLogicOp	()
				const
				{ return(binaryLogicOp_); }

  //  PURPOSE:  To return the address of the VariableMention that encodes
  //	'*this' Node.
  VariableMention*
		getVarPtr	()
				const
				{ return(lhsVarPtr_); }

  //  PURPOSE:  To return the VariableMention that encodes '*this' Node.
  VariableMention&
		getVar		()
				const
				{ return(*lhsVarPtr_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  simpleType_ty	lhsType;
				  simpleType_ty	rhsType;

				  //  Compile 'lhsOperandPtr_' and
				  //    set 'lhsVarPtr_' equal to variable
				  //	it returns.
				  //  Compile 'rhsOperandPtr_' and
				  //    set 'rhsVarPtr_' equal to variable
				  //	it returns.
				  //  Make sure they both return type
				  //    BOOLEAN_ST.
				  //  Set 'simpleType' to 'BOOLEAN_ST'
				  //  Return 'lhsVarPtr_'
				  return(NULL);	// <-- Change that 'NULL'
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  // Write both operands,
				  // Then write the comparison for this node
				  //   (look at binaryLogicOpName[] and
				  //    method getBinaryLogicOp())
				}

};


//  PURPOSE:  To represent the occurrence of a binary math operation in the
//	Pascal source code.
class		BinaryMathOpNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the operation that '*this' node represents.
  binaryMathOp_ty		binaryMathOp_;

  //  PURPOSE:  To hold the address of the left-hand-side operand.
  Node*				lhsOperandPtr_;

  //  PURPOSE:  To hold the address of the right-hand-side operand.
  Node*				rhsOperandPtr_;

  //  PURPOSE:  To hold the type of the left-hand side.
  simpleType_ty			lhsType_;

  //  PURPOSE:  To hold the type of the right-hand side.
  simpleType_ty			rhsType_;

  //  PURPOSE:  To hold the type of the expression computed by '*this'
  //	expression.
  simpleType_ty			returnType_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*lhsOperandPtr_'.
  VariableMention*		lhsVarPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*rhsOperandPtr_'.
  VariableMention*		rhsVarPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	conversion from int to real for either the LHS or RHS.
  VariableMention*		convertVarPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  BinaryMathOpNode&
		operator=	(const BinaryMathOpNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of the operation
  //	'newOp' operating on '*newLhsPtr' and '*newRhsPtr' in the Pascal
  //	source.  No return value.
  BinaryMathOpNode		(binaryMathOp_ty	newOp,
				 Node*			newLhsPtr,
  				 Node*			newRhsPtr
				) :
				Node(),
				binaryMathOp_(newOp),
				lhsOperandPtr_(newLhsPtr),
				rhsOperandPtr_(newRhsPtr),
				lhsVarPtr_(NULL),
				rhsVarPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~BinaryMathOpNode		()
				{
				  delete(convertVarPtr_);
				  delete(rhsOperandPtr_);
				  delete(lhsOperandPtr_);
				  //  Do _not_ delete() 'rhsVarPtr_',
				  //    '*this' does not own it.
				  //  Do _not_ delete() 'lhsVarPtr_',
				  //    '*this' does not own it.
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the operation that '*this' node represents.  No
  //	parameters.
  binaryMathOp_ty
		getBinaryMathOp	()
				const
				{ return(binaryMathOp_); }

  //  PURPOSE:  To return the address of the VariableMention that encodes
  //	'*this' Node.
  VariableMention*
		getVarPtr	()
				const
				{ return(lhsVarPtr_); }

  //  PURPOSE:  To return the VariableMention that encodes '*this' Node.
  VariableMention&
		getVar		()
				const
				{ return(*lhsVarPtr_); }

  //  PURPOSE:  To hold the type of the left-hand side.
  simpleType_ty	getLhsType	()
				const
				{ return(lhsType_); }

  //  PURPOSE:  To hold the type of the right-hand side.
  simpleType_ty	getRhsType	()
				const
				{ return(rhsType_); }

  //  PURPOSE:  To hold the type of the expression computed by '*this'
  //	expression.
  simpleType_ty	getReturnType	()
				const
				{ return(returnType_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  //  Compile 'lhsOperandPtr_' and
				  //    set 'lhsVarPtr_' equal to variable
				  //	it returns and 'lhsType_' equal to
				  //	its type.
				  //  Ditto for 'rhsOperandPtr_', 'rhsVarPtr_'
				  //    and 'rhsType_'.

				  //  Check that these types are numeric

				  //  If they are both integers then make
				  //    Sure not doing 'REAL_DIVIDE_BMO'.
				  //    Set 'returnType_' and 'simpleType' to
				  //	the 'INTEGER_ST' and return
				  //	'lhsVarPtr_'.

				  //  If they are both reals then make
				  //    Sure not doing 'INT_DIVIDE_BMO'.
				  //    Set 'returnType_' and 'simpleType' to
				  //	the 'REAL_ST' and return
				  //	'lhsVarPtr_'.

				  //  If get here then one is a int and the
				  //    other real.  Will convert to real
				  //	but first make sure not doing
				  //	'INT_DIVIDE_BMO'

				  //  Now set 'convertVarPtr_' to a new
				  //    variable (just do new VariableMention())
				  //    Set 'returnType_' and 'simpleType' to
				  //	'REAL_ST'.
				  //	If the LHS is the integer then actually
				  //	the conversion variable will be returned
				  //	else it will be the LHS variable.
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  // Write both operands,

				  //  If the LHS has type integer and RHS
				  //    has type real, then write a
				  //    intToReal conversion that converts
				  //    the LHS variable to the conversion var.
				  //  The write the instruction with
				  //    binaryMathOpName[getBinaryMathOp()]
				  //    and the conversion var and RHS as args.

				  //  If the RHS has type integer and LHS
				  //    has type real, then write a
				  //    intToReal conversion that converts
				  //    the RHS variable to the conversion var.
				  //  The write the instruction with
				  //    binaryMathOpName[getBinaryMathOp()] and
				  //    the LHS var and conversion var as args.

				  //  If ther is no conversion then write the
				  //    binary comparison for this node with
				  //    LHS and RHS
				}

};


//  PURPOSE:  To represent the occurrence of a comparison operation in the
//	Pascal source code.
class		ComparisonOpNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the operation that '*this' node represents.
  comparisonOp_ty		comparisonOp_;

  //  PURPOSE:  To hold the address of the left-hand-side operand.
  Node*				lhsOperandPtr_;

  //  PURPOSE:  To hold the address of the right-hand-side operand.
  Node*				rhsOperandPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the result of comparison for which '*this' encodes.
  VariableMention*		varPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*lhsOperandPtr_'.
  VariableMention*		lhsVarPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*rhsOperandPtr_'.
  VariableMention*		rhsVarPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  ComparisonOpNode&
		operator=	(const ComparisonOpNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of comparison
  //	'newOp' between the code generated by '*newLhsPtr' and that of
  //	'*newRhsPtr'.  No return value.
  ComparisonOpNode		(comparisonOp_ty	newOp,
				 Node*			newLhsPtr,
  				 Node*			newRhsPtr
				) :
				Node(),
				comparisonOp_(newOp),
				lhsOperandPtr_(newLhsPtr),
				rhsOperandPtr_(newRhsPtr),
				varPtr_(NULL),
				lhsVarPtr_(NULL),
				rhsVarPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~ComparisonOpNode		()
				{
				  delete(rhsOperandPtr_);
				  delete(lhsOperandPtr_);
				  delete(varPtr_);
				  //  Do _not_ delete() 'rhsVarPtr_',
				  //    '*this' does not own it.
				  //  Do _not_ delete() 'lhsVarPtr_',
				  //    '*this' does not own it.
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the operation that '*this' node represents.  No
  //	parameters.
  comparisonOp_ty
		getComparisonOp	()
				const
				{ return(comparisonOp_); }

  //  PURPOSE:  To return the address of the VariableMention that encodes
  //	'*this' Node.
  VariableMention*
		getVarPtr	()
				const
				{ return(lhsVarPtr_); }

  //  PURPOSE:  To return the VariableMention that encodes '*this' Node.
  VariableMention&
		getVar		()
				const
				{ return(*lhsVarPtr_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  simpleType_ty	lhsType;
				  simpleType_ty	rhsType;

				  //  Compile 'lhsOperandPtr_' and
				  //    set 'lhsVarPtr_' equal to variable
				  //	it returns.
				  //  Compile 'rhsOperandPtr_' and
				  //    set 'rhsVarPtr_' equal to variable
				  //	it returns.
				  //  Make sure they both return type the same
				  //    type.
				  //  Set 'simpleType' to 'BOOLEAN_ST'
				  //  Make 'varPtr_' be a new VariableMention
				  //    (Just do 'new VariableMention');
				  //  Return 'varPtr_'
				  return(NULL);	// <-- Change that 'NULL'
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  // Write both operands,
				  // Then write the 3-variable operation for
				  //    this node (look at comparisonOpName[]
				  //     and method getComparisonOp())
				}

};


//  PURPOSE:  To represent the occurrence of an assignment operation in the
//	Pascal source code.
class		AssignmentNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the address of the left-hand-side operand.
  Node*				lhsOperandPtr_;

  //  PURPOSE:  To hold the address of the right-hand-side operand.
  Node*				rhsOperandPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*lhsOperandPtr_'.
  VariableMention*		lhsVarPtr_;

  //  PURPOSE:  To hold the address of the variable that will receive the
  //  	the value computed by the code represented by '*rhsOperandPtr_'.
  VariableMention*		rhsVarPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  AssignmentNode&
		operator=	(const AssignmentNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make '*this' node represent the occurrence of the
  //	assignment of '*newLhsPtr' to '*newRhsPtr' in the Pascal source.
  //	No return value.
  AssignmentNode		(Node*			newLhsPtr,
  				 Node*			newRhsPtr
				) :
				Node(),
				lhsOperandPtr_(newLhsPtr),
				rhsOperandPtr_(newRhsPtr)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~AssignmentNode		()
				{
				  delete(rhsOperandPtr_);
				  delete(lhsOperandPtr_);
				  //  Do _not_ delete() 'rhsVarPtr_',
				  //    '*this' does not own it.
				  //  Do _not_ delete() 'lhsVarPtr_',
				  //    '*this' does not own it.
				}

  //  V.  Accessors:
  //  PURPOSE:  To return the address of the VariableMention that encodes
  //	'*this' Node.
  VariableMention*
		getVarPtr	()
				const
				{ return(lhsVarPtr_); }

  //  PURPOSE:  To return the VariableMention that encodes '*this' Node.
  VariableMention&
		getVar		()
				const
				{ return(*lhsVarPtr_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*
		compile		(simpleType_ty&	simpleType
				)
				{
				  simpleType_ty	lhsType;
				  simpleType_ty	rhsType;

				  //  Compile 'lhsOperandPtr_' and
				  //    set 'lhsVarPtr_' equal to variable
				  //	it returns.
				  //  Compile 'rhsOperandPtr_' and
				  //    set 'rhsVarPtr_' equal to variable
				  //	it returns.
				  //  Make sure their types match
				  //  Set 'simpleType' to 'NO_TYPE_ST'
				  //  Return 'NULL'
				  return(NULL);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  // Write both operands,
				  // Then copy from the 2nd argument to the 1st
				}

};


//  PURPOSE:  To represent an if-statement
class		IfNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the address of the condition.
  Node*				conditionPtr_;

  //  PURPOSE:  To hold the address of the then statement.
  Node*				thenPtr_;

  //  PURPOSE:  To hold the address of the else statement.
  Node*				elsePtr_;

  //  PURPOSE:  To hold the address of variable computed by the
  //	'*conditionPtr_'
  VariableMention*		conditionVarPtr_;

  //  PURPOSE:  To hold the address of the label to the else.
  LabelMention*			labelElsePtr_;

  //  PURPOSE:  To hold the address of the label to the after.
  LabelMention*			labelAfterPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  IfNode&	operator=	(const IfNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To create an if-statement.  'newConditionPtr' points to the 
  //	condition.  'newThenPtr' points to the code to do for "THEN".
  //	'newElsePtr' points to the (optional) code to do for "ELSE".
  //	No return value.
  IfNode			(Node*	newConditionPtr,
				 Node*	newThenPtr,
				 Node*	newElsePtr	= NULL
				) :
				Node(),
				conditionPtr_(newConditionPtr),
				thenPtr_(newThenPtr),
				elsePtr_(newElsePtr),
				conditionVarPtr_(NULL),
				labelElsePtr_(NULL),
				labelAfterPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~IfNode			()
				{
				  //  Do _not_ delete() conditionVarPtr_,
				  //    '*this' does not own it.
				  delete(elsePtr_);
				  delete(thenPtr_);
				  delete(conditionPtr_);
				}

  //  V.  Accessors:

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*		compile
				(simpleType_ty&	simpleType
				)
				{
				  //  Compile 'conditionPtr_' and
				  //    set 'conditionVarPtr_' equal to variable
				  //	it returns.
				  //  Make sure it returns 'BOOLEAN_ST'
				  //  Compile 'thenPtr_' (if it exists)
				  //  Compile 'elsePtr_' (if it exists)
				  //  Set 'labelAfterPtr_' to a new label
				  //    (just call 'new LabelMention')
				  //  Set 'labelElsePtr_' to a new label
				  //    (just call 'new LabelMention')
				  //  Set 'simpleType' to 'NO_TYPE_ST'
				  //  Return 'NULL'
				  return(NULL);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  //  Write assembly for 'conditionPtr_'

				  //  If there is an "else" then
				  //    have a 'ifFalseGoto' statement test
				  //	'conditionVarPtr_' and make it jump
 				  //	to labelElsePtr_.
				  //  However, if there is no "else" then
				  //    have a 'ifFalseGoto' statement test
				  //	'conditionVarPtr_' and make it jump
				  //	to labelAfterPtr_.
				  //

				  //  Write assembly for 'thenPtr_'
				  //  Write a 'goto' that jumps to
 				  //    'labelAfterPtr'
				}

};


//  PURPOSE:  To represent a for loop
class		ForNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the address of the looping variable.
  Node*				variablePtr_;

  //  PURPOSE:  To hold the address of the initialization expression.
  Node*				initExprPtr_;

  //  PURPOSE:  To hold the address of the terminating expression.
  Node*				termExprPtr_;

  //  PURPOSE:  To hold the address of the body of the loop.
  Node*				bodyPtr_;

  //  PURPOSE:  To hold the increment amount, either +1 or -1
  int				increment_;

  //  PURPOSE:  To hold the address of variable computed by the
  //	'*variablePtr_'
  VariableMention*		varVarPtr_;

  //  PURPOSE:  To hold the address of variable computed by the
  //	'*initExprPtr_'
  VariableMention*		initVarPtr_;

  //  PURPOSE:  To hold the address of variable computed by the
  //	'*termExprPtr_'
  VariableMention*		termVarPtr_;

  //  PURPOSE:  To hold the address of variable computed by the comparison of
  //	'varVarPtr_' with 'termVarPtr_'
  VariableMention*		compVarPtr_;

  //  PURPOSE:  To hold the address of the label to the condition.
  LabelMention*			labelCondPtr_;

  //  PURPOSE:  To hold the address of the label to the after.
  LabelMention*			labelAfterPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  ForNode&	operator=	(const ForNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To create a for-statement.  'newVariablePtr' points to the
  //	node for the variable that controls the loop.  'newInitExprPtr' points
  //	to the initialization expression.  'newTermExprPtr' points to the
  //	terminal expression.  'newBodyPtr' points to the body.  'newIncrement'
  //	is either '+1' if the loop counts up ("TO"), or -1 if the loop counts
  //	down ("DOWNTO").  No return value.
  ForNode			(Node*	newVariablePtr,
				 Node*	newInitExprPtr,
				 Node*	newTermExprPtr,
				 Node*	newBodyPtr,
				 int	newIncrement
				) :
				Node(),
				variablePtr_(newVariablePtr),
				initExprPtr_(newInitExprPtr),
				termExprPtr_(newTermExprPtr),
				bodyPtr_(newBodyPtr),
				increment_(newIncrement),
				varVarPtr_(NULL),
				initVarPtr_(NULL),
				termVarPtr_(NULL),
				compVarPtr_(NULL),
				labelCondPtr_(NULL),
				labelAfterPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~ForNode			()
				{
				  delete(labelAfterPtr_);
				  delete(labelCondPtr_);
				  //  Do _not_ delete() 'varVarPtr_',
				  //    'initVarPtr_' or 'termVarPtr_',
				  //    '*this' does not own them.
				  delete(compVarPtr_);
				  delete(bodyPtr_);
				  delete(termExprPtr_);
				  delete(initExprPtr_);
				  delete(variablePtr_);
				}

  //  V.  Accessors:

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*		compile
				(simpleType_ty&	simpleType
				)
				{
				  //  Compile 'variablePtr_' and
				  //    set 'varVarPtr_' equal to variable
				  //	it returns.
				  //  Make sure it returns 'INTEGER_ST'
 
				  //  Compile 'initExprPtr_' and
				  //    set 'initVarPtr_' equal to variable
 				  //	it returns.
				  //  Make sure it returns 'INTEGER_ST'

				  //  Compile 'termExprPtr_' and
 				  //    set 'termVarPtr_' equal to variable
 				  //	it returns.
				  //  Make sure it returns 'INTEGER_ST'

				  //  Compile 'bodyPtr_'
				  //  Make new labels 'labelCondPtr_' and
				  //    'labelAfterPtr_'
				  //  Make new variable 'compVarPtr'

				  //  Set 'simpleType' to 'NO_TYPE_ST'
				  //  Return 'NULL'
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  //  Write 'initExprPtr_'
				  //  Copy *initVarPtr_ into *varVarPtr_
				  //  Write label *labelCondPtr_
				  //  Write termExprPtr_

				  //  If 'increment_' == '1' test if
				  //    *varVarPtr_ is greater then 
				  //	*termVarPtr_, put the result in
				  //	*compVarPtr_
				  //  If 'increment_' == '1' test if
				  //    *varVarPtr_ is lesser

				  //  If *labelAfterPtr_ is true, "goto"
				  //    *labelAfterPtr_

				  //  Write 'bodyPtr_'
				  //  Add constant 'increment_' to 'varVarPtr_'
				  //  "goto" *labelCondPtr

				  //  Write label '*labelAfterPtr_'
				}

};


//  PURPOSE:  To represent either a 'write' or a 'writeln'.
class	      	WriteNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold 'true' if '*this' represents a 'writeln' (if it should
  //	 add a newline should be added at the end), or 'false' otherwise.
  bool				shouldPrintNewlineChar_;

  //  PURPOSE:  To point to the optional expression to whose value is to print.
  Node*				exprPtr_;

  //  PURPOSE:  To hold the address of variable computed by the
  //	'*exprPtr_'
  VariableMention*		exprVarPtr_;

  //  II.  Disallowed auto-generated methods:
  //  No default constructor:
  WriteNode			();

  //  No copy constructor:
  WriteNode			(const WriteNode&
				);

  //  No copy assignment op:
  WriteNode&	operator=	(const WriteNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To initialize '*this' to represent a 'write' (if
  //	 'shouldPrintNewlineChar' == 'false') or a 'writeln' (if
  //	 'shouldPrintNewlineChar' == 'true') that prints the result of
  //	'*exprPtr' (assuming the address is not NULL).  No return value.
  WriteNode			(bool		shouldPrintNewlineChar,
  				 Node*		exprPtr	= NULL
				) :
				Node(),
				shouldPrintNewlineChar_(shouldPrintNewlineChar),
				exprPtr_(exprPtr),
				exprVarPtr_(NULL)
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~WriteNode			()
  				{
				  delete(exprPtr_);
				}

  //  V.  Accessors:
  //  PURPOSE:  To hold 'true' if '*this' represents a 'writeln' (if it should
  //	 add a newline should be added at the end), or 'false' otherwise.
  bool		getShouldPrintNewlineChar
				()
				const
				{ return(shouldPrintNewlineChar_); }

  //  PURPOSE:  To point to the optional expression to whose value is to print.
  Node*		getExprPtr 	()
				const
				{ return(exprPtr_); }

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*		compile
				(simpleType_ty&	simpleType
				)
				{
				  simpleType_ty		exprSimpleType;

				  if  ( getExprPtr() != NULL )
				    exprVarPtr_ =
					getExprPtr()->compile(exprSimpleType);

				  simpleType		     = NO_TYPE_ST;
				  return(NULL);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  //  If there is a newline char at the end
				  //   then write stdOutPrintLn, else
				  //   write stdOutPrint.

				  //  Then write the expression var
				}

};


//  PURPOSE:  To represent a sequence of statements to do.
class		StatementListNode : public Node
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the addresses of the Node instances of the statements
  //  	to do in sequence.
  std::list<Node*>		list_;

  //  II.  Disallowed auto-generated methods:
  //  No copy assignment op:
  StatementListNode&
		operator=	(const StatementListNode&
				);

protected :
  //  III.  Protected methods:

public :
  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To create an empty list node.  No parameters.  No return value.
  StatementListNode		() :
				Node(),
				list_()
				{ }

  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return
  //	value.
  ~StatementListNode		()
				{
				  std::list<Node*>::iterator iter=list_.begin();
				  std::list<Node*>::iterator end =list_.end();

				  for  ( ;  iter != end;  iter++)
				  {
				    delete(*iter);
				    *iter	= NULL;
				  }
				}

  //  V.  Accessors:

  //  VI.  Mutators:

  //  VII.  Misc methods that do main work of type:
  //  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is
  //  	set to the type that the code generated by '*this' node returns (or
  //	 to 'NO_TYPE_ST' if it does not return a value).  Returns the address
  //	 of a VariableMention that the code generated by '*this' node updates
  //	(or 'NULL' if there is no such variable).
  VariableMention*		compile
				(simpleType_ty&	simpleType
				)
				{
				  VariableMention*	     toReturn	= NULL;
				  std::list<Node*>::iterator iter=list_.begin();
				  std::list<Node*>::iterator end =list_.end();

				  simpleType		     = NO_TYPE_ST;

				  for  ( ;  iter != end;  iter++)
				  {
				    toReturn = (*iter)->compile(simpleType);
				  }

				  return(toReturn);
				}

  //  PURPOSE:  To output the assembly language translate of '*this' node to
  //  	'output'.  No return value.
  void		writeAssembly	(std::ostream&	output
				)
				{
				  std::list<Node*>::iterator iter=list_.begin();
				  std::list<Node*>::iterator end =list_.end();

				  for  ( ;  iter != end;  iter++)
				  {
				    (*iter)->writeAssembly(output);
				  }
				}

  //  PURPOSE:  To add 'nodePtr' to the end of '*this' list.  No return value.
  void		append		(Node*		nodePtr
				)
				{
				  if  (nodePtr != NULL)
				  {
				    list_.push_back(nodePtr);
				  }
				}

};
