{"changed":true,"filter":false,"title":"laundryLang","tooltip":"/laundryLang","value":"#include\t<cstdlib>\n#include\t<cstdio>\n#include\t<iostream>\n#include\t<string>\n#include\t<list>\n#include\t<map>\n\n\n//  PURPOSE:  To tell the length of a global string.\nconst int\tTEXT_LEN\t\t= 256;\n\n\n//  PURPOSE:  To represent the different lexemes in the language.\ntypedef\t\tenum\n\t\t{\n\t\t  END_OF_INPUT_SYM,\n\n\t\t  STRING_SYM,\n\t\t  NUMBER_SYM,\n\n\t\t  COMMA_SYM,\n\t\t  PERIOD_SYM,\n\t\t  BEGIN_PAREN_SYM,\n\t\t  END_PAREN_SYM,\n\n\t\t  WASH_KEYWORD_SYM,\n\t\t  DRY_KEYWORD_SYM,\n\n\t\t  LIGHTS_KEYWORD_SYM,\n\t\t  DARKS_KEYWORD_SYM,\n\t\t  DELICATES_KEYWORD_SYM,\n\n\t\t  MACHINE_KEYWORD_SYM,\n\t\t  HAND_KEYWORD_SYM,\n\t\t  BY_KEYWORD_SYM,\n\n\t\t  HOT_KEYWORD_SYM,\n\t\t  WARM_KEYWORD_SYM,\n\t\t  COLD_KEYWORD_SYM,\n\n\t\t  LINE_KEYWORD_SYM,\n\t\t  TUMBLE_KEYWORD_SYM,\n\n\t\t  TROUSERS_KEYWORD_SYM,\n\t\t  SHIRTS_KEYWORD_SYM,\n\t\t  UNDERWEAR_KEYWORD_SYM,\n\t\t  SHEETS_KEYWORD_SYM\n\t\t}\n\t\tsymbol_ty;\n\n//  PURPOSE:  To represent the string delimitor character.\nconst char\tQUOTE_CHAR\t\t= 0x22;\n\n\n//  PURPOSE:  To represent the decimal point character.\nconst char\tDECIMAL_PT_CHAR\t\t= '.';\n\n\n//  PURPOSE:  To represent the period character.\nconst char\tPERIOD_CHAR\t\t= '.';\n\n\n/*  PURPOSE:  To implement an interface that manages the character source.\n */\nclass\tInputCharStream\n{\n  //  I.  Member vars:\n  //  PURPOSE:  To hold the input.\n  std::string\t\tinput_;\n\n  //  PURPOSE:  To hold where the cursor is.\n  int\t\t\tindex_;\n\n  //  II.  Disallowed auto-generated methods:\n  \n  //  III.  Protected methods:\nprotected :\n\npublic:\n  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:\n  //  PURPOSE:  To\n  InputCharStream\t(std::string&\tnewInput\n  \t\t\t) :\n\t\t\tinput_(newInput),\n\t\t\tindex_(0)\n\t\t\t{ }\n\n  //  V.  Accessors:\n\n  //  VI.  Mutators:\n\n  //  VII.  Methods that do main and misc work of class:\n  //  PURPOSE:  To return the current char, or '\\0' if there are no more.\n  //\tNo parameters.\n  char\t\tpeek\t()\n  \t\t\tconst\n\t\t\t{ return\n\t\t\t  ( (index_ >= input_.length())\n\t\t\t    ? '\\0' : input_[index_]\n\t\t\t  );\n\t\t\t}\n\n  //  PURPOSE:  To return 'true' if at eof-of-input, or 'false' otherwise.\n  bool\t\tisAtEnd\t()\n  \t\t\tconst\n\t\t\t{ return(index_ >= input_.length()); }\n\n  //  PURPOSE:  To advance to the next char (if not already at end).  No\n  //\tparameters.  No return value.\n  void\t\tadvance\t()\n\t\t\t{\n\t\t\t  if  (index_ < input_.length())  index_++;\n\t\t\t}\n\n};\n\n\n//  PURPOSE:  To represent a parsed symbol, and any associated data.\nclass\t\tSymbol\n{\n  //  I.  Member vars:\n  //  PURPOSE:  To tell the type of symbol that '*this' represents.\n  symbol_ty\t\t\tsymbol_;\n\n  //  PURPOSE:  To hold the address of a string associated with '*this' symbol\n  //\t(if there is one).\n  std::string*\t\t\tstringPtr_;\n\n  //  PURPOSE:  To hold the number associated with '*this' symbol (if there\n  //\tis one).\n  double\t\t\tnumber_;\n\n  //  II.  Disallowed auto-generated methods:\n  //  No default constructor:\n  Symbol\t\t\t();\n\n  //  No copy constructor:\n  Symbol\t\t\t(const Symbol&\n\t\t\t\t);\n\n  //  No copy assignment op:\n  Symbol&\toperator=\t(const Symbol&\n\t\t\t\t);\n\nprotected :\n  //  III.  Protected methods:\n\npublic :\n  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:\n  //  PURPOSE:  To initialize '*this' to hold symbol 'newSymbol'.  No return\n  //\tvalue.\n  Symbol\t\t\t(symbol_ty\tnewSymbol\n\t\t\t\t) :\n\t\t\t\tsymbol_(newSymbol),\n\t\t\t\tstringPtr_(NULL),\n\t\t\t\tnumber_(0.0)\n\t\t\t\t{ }\n\n  //  PURPOSE:  To initialize '*this' to hold string 'newString'.  No return\n  //\tvalue.\n  Symbol\t\t\t(const std::string&\tnewString\n  \t\t\t\t) :\n\t\t\t\tsymbol_(STRING_SYM),\n\t\t\t\tstringPtr_(new std::string(newString)),\n\t\t\t\tnumber_(0.0)\n\t\t\t\t{ }\n\t\t\t\t\n  //  PURPOSE:  To initialize '*this' to hold number 'newNumber'.  No return\n  //\tvalue.\n  Symbol\t\t\t(double\tnewNumber\n\t\t\t\t) :\n\t\t\t\tsymbol_(NUMBER_SYM),\n\t\t\t\tstringPtr_(NULL),\n\t\t\t\tnumber_(newNumber)\n\t\t\t\t{ }\n\n  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return\n  //\tvalue.\n  ~Symbol\t\t\t()\n\t\t\t\t{\n\t\t\t\t  delete(stringPtr_);\n\t\t\t\t}\n\n  //  V.  Accessors:\n  //  PURPOSE:  To return the type associated with '*this' Symbol.  No\n  //  \tparameters.\n  symbol_ty\tgetType\t\t()\n\t\t\t\tconst\n\t\t\t\t{ return(symbol_); }\n\n  //  PURPOSE:  To return a reference to the string stored at '*this' Symbol,\n  //\tor a reference to the empty string if '*this' is not a string.\n  const std::string&\n\t\tgetString\t()\n\t\t\t\tconst\n\t\t\t\t{\n\t\t\t\t  static std::string\tempty(\"\");\n\n\t\t\t\t  return( (stringPtr_ == NULL)\n\t\t\t\t  \t  ? empty\n\t\t\t\t\t  : *stringPtr_\n\t\t\t\t\t);\n\t\t\t\t}\n\n  //  PURPOSE:  To return the number stored at '*this' Symbol, or '0' if\n  //\t'*this' does not represent a number.\n  double\tgetNumber\t()\n\t\t\t\tconst\n\t\t\t\t{ return(number_); }\n\n};\n\n\n//  PURPOSE:  To hold a shared global array of characters.\nchar\t\t\t\ttext[TEXT_LEN];\n\n\n//  PURPOSE:  To implement an interface that gathers characters into lexemes.\nclass\tTokenStream\n{\n  //  I.  Member vars:\n  //  PURPOSE:  To hold the source of the character input.\n  InputCharStream&\tinputCharStream_;\n\n  //  PURPOSE:  To hold the lastest lexeme parsed.\n  Symbol*\t   \tlastParsedPtr_;\n\n  //  PURPOSE:  To hold the keyword string to symbol_ty mapping.\n  std::map<std::string,symbol_ty>\n\t\t\tkeywordToSymbolTMap_;\n\n  //  II.  Disallowed auto-generated methods:\n  //  No default constructor:\n  TokenStream\t\t();\n\n  //  No copy constructor:\n  TokenStream\t\t(const TokenStream&\n\t\t\t);\n\n  //  No copy assignment op:\n  TokenStream&\t\toperator=\n\t\t\t(const TokenStream&\n\t\t\t);\n\nprotected :\n  //  III.  Protected methods:\n  //  PURPOSE:  To return a pointer representing a scanned string constant.\n  //\tNo parameters.\n  Symbol*\tscanString\t()\n\t\t\t\t{\n\t\t\t\t  std::string\tlex(\"\");\n\t\t\t\t  bool\t\thaveFoundEnd\t= false;\n\n\t\t\t\t  //  Advance past first quote:\n\t\t\t\t  inputCharStream_.advance();\n\n\t\t\t\t  while  ( !inputCharStream_.isAtEnd() )\n\t\t\t\t  {\n\t\t\t\t    char\tc = inputCharStream_.peek();\n\n\t\t\t\t    inputCharStream_.advance();\n\n\t\t\t\t    if  (c == QUOTE_CHAR)\n\t\t\t\t    {\n\t\t\t\t      haveFoundEnd\t= true;\n\t\t\t\t      break;\n\t\t\t\t    }\n\n\t\t\t\t    lex\t+= c;\n\t\t\t\t  }\n\n\t\t\t\t  if  (!haveFoundEnd)\n\t\t\t\t    throw \"Non-terminated string constant\";\n\n\t\t\t\t  return(new Symbol(lex));\n\t\t\t\t}\n\n  //  PURPOSE:  To return a pointer representing a scanned number.  No\n  //\tparameters.\n  Symbol*   \tscanNumber\t()\n\t\t\t\t{\n\t\t\t\t  bool\t\thaveSeenDecimalPt\t= false;\n\t\t\t\t  std::string\tlex(\"\");\n\t\t\t\t  char\t\tc;\n\n\t\t\t\t  while  ( c = inputCharStream_.peek(),\n\t\t\t\t  \t   isdigit(c)\n\t\t\t\t  \t   || ( (c == DECIMAL_PT_CHAR)\n\t\t\t\t\t\t&&\n\t\t\t\t\t\t!haveSeenDecimalPt\n\t\t\t\t\t      )\n\t\t\t\t  \t )\n\t\t\t\t  {\n\t\t\t\t    lex\t\t       += c;\n\t\t\t\t    haveSeenDecimalPt\t= (c==DECIMAL_PT_CHAR);\n\t\t\t\t    inputCharStream_.advance();\n\t\t\t\t  }\n\n\t\t\t\t  return(new Symbol(atof(lex.c_str())));\n\t\t\t\t}\n\n\n  //  PURPOSE:  To return a pointer to a Symbol instance representing an\n  //\taddress.\n  Symbol*\tscanIdentifier\t()\n  \t\t\t\t{\n\t\t\t\t  std::string\tlex(\"\");\n\t\t\t\t  char\t\tc;\n\n\t\t\t\t  lex\t+= tolower(inputCharStream_.peek());\n\t\t\t\t  inputCharStream_.advance();\n\n\t\t\t\t  while  (c = inputCharStream_.peek(),\n\t\t\t\t  \t   isalnum(c) || (c == '_')\n\t\t\t\t  \t )\n\t\t\t\t  {\n\t\t\t\t    lex\t\t       += tolower(c);\n\t\t\t\t    inputCharStream_.advance();\n\t\t\t\t  }\n\n\t\t\t\t  std::map<std::string,symbol_ty>::iterator\n\t\t\t\t    iter = keywordToSymbolTMap_.find(lex);\n\n\t\t\t\t  if  (iter != keywordToSymbolTMap_.end())\n\t\t\t\t    return(new Symbol(iter->second));\n\n\t\t\t\t  std::string\tkeywords;\n\t\t\t\t  bool\t\tisFirst\t= true;\n\n\t\t\t\t  for  (iter  = keywordToSymbolTMap_.begin();\n\t\t\t\t        iter != keywordToSymbolTMap_.end();\n\t\t\t\t\titer++\n\t\t\t\t       )\n\t\t\t\t  {\n\t\t\t\t    if  (isFirst)\n\t\t\t\t      isFirst\t = false;\n\t\t\t\t    else\n\t\t\t\t      keywords\t+= \", \";\n\n\t\t\t\t    keywords += iter->first;\n\t\t\t\t  }\n\n\t\t\t\t  snprintf\n\t\t\t\t\t(text,TEXT_LEN,\n\t\t\t\t\t \"Expected one of %s, not %s\",\n\t\t\t\t\t keywords.c_str(),lex.c_str()\n\t\t\t\t\t);\n\t\t\t\t  throw text;\n\t\t\t\t}\n\n  //  PURPOSE:  To return a pointer representing a scanned Symbol, or to return\n  //\t'new Symbol(END_OF_INPUT_SYM)' if the '*this' is at the end-of-input.\n  //\tNo parameters.\n  Symbol*\tscanner\t\t()\n  \t\t\t\t{\n\t\t\t\t  while  ( isspace(inputCharStream_.peek()) )\n\t\t\t\t    inputCharStream_.advance();\n\n\t\t\t\t  if  ( inputCharStream_.isAtEnd() )\n\t\t\t\t    return( new Symbol(END_OF_INPUT_SYM) );\n\n\t\t\t\t  if  ( inputCharStream_.peek() == QUOTE_CHAR )\n\t\t\t\t    return( scanString() );\n\n\t\t\t\t  if  ( isdigit(inputCharStream_.peek()) )\n\t\t\t\t    return( scanNumber() );\n\n\t\t\t\t  if  ( isalpha(inputCharStream_.peek())\n\t\t\t\t        || (inputCharStream_.peek() == '_')\n\t\t\t\t      )\n\t\t\t\t    return( scanIdentifier() );\n\n\t\t\t\t  char\t  ch\t    = inputCharStream_.peek();\n\t\t\t\t  Symbol* symbolPtr = NULL;\n\n\t\t\t\t  inputCharStream_.advance();\n\n\t\t\t\t  switch  (ch)\n\t\t\t\t  {\n\t\t\t\t  case '(' :\n\t\t\t\t    symbolPtr\t= new Symbol(BEGIN_PAREN_SYM);\n\t\t\t\t    break;\n\n\t\t\t\t  case ')' :\n\t\t\t\t    symbolPtr\t= new Symbol(END_PAREN_SYM);\n\t\t\t\t    break;\n\n\t\t\t\t  case ',' :\n\t\t\t\t    symbolPtr\t= new Symbol(COMMA_SYM);\n\t\t\t\t    break;\n\n\t\t\t\t  case PERIOD_CHAR :\n\t\t\t\t    symbolPtr\t= new Symbol(PERIOD_SYM);\n\t\t\t\t    break;\n\n\t\t\t\t  default :\n\t\t\t\t    throw \"Unexpected character in input\";\n\t\t\t\t  }\n\n\t\t\t\t  return(symbolPtr);\n\t\t\t\t}\n\npublic :\n  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:\n  //  PURPOSE:  To initialize '*this' to tokenize given characters read from\n  //  \t'newInputCharStream'.  No parameters.\n  TokenStream\t\t\t(InputCharStream&\tnewInputCharStream\n\t\t\t\t) :\n\t\t\t\tinputCharStream_(newInputCharStream),\n\t\t\t\tlastParsedPtr_(NULL)\n\t\t\t\t{\n\t\t\t\t  keywordToSymbolTMap_[\".\"]\n\t\t\t\t\t= PERIOD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"wash\"]\n\t\t\t\t\t= WASH_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"dry\"]\n\t\t\t\t\t= DRY_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"lights\"]\n\t\t\t\t\t= LIGHTS_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"darks\"]\n\t\t\t\t\t= DARKS_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"delicates\"]\n\t\t\t\t\t= DELICATES_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"machine\"]\n\t\t\t\t\t= MACHINE_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"hand\"]\n\t\t\t\t\t= HAND_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"by\"]\n\t\t\t\t\t= BY_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"hot\"]\n\t\t\t\t\t= HOT_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"warm\"]\n\t\t\t\t\t= WARM_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"cold\"]\n\t\t\t\t\t= COLD_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"line\"]\n\t\t\t\t\t= LINE_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"tumble\"]\n\t\t\t\t\t= TUMBLE_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"trousers\"]\n\t\t\t\t\t= TROUSERS_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"shirts\"]\n\t\t\t\t\t= SHIRTS_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"underwear\"]\n\t\t\t\t\t= UNDERWEAR_KEYWORD_SYM;\n\t\t\t\t  keywordToSymbolTMap_[\"sheets\"]\n\t\t\t\t\t= SHEETS_KEYWORD_SYM;\n\t\t\t\t  advance();\n\t\t\t\t}\n\n  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return\n  //\tvalue.\n  ~TokenStream\t\t\t()\n\t\t\t\t{ }\n\n  //  V.  Accessors:\n\n  //  VI.  Mutators:\n\n  //  VII.  Methods that do main and misc work of class:\n  //  PURPOSE:  To return the 'symbol_ty' of the 'Symbol' instance that is next\n  //\tin the symbol stream.  No parameters.\n  symbol_ty   \tpeek\t\t()\n\t\t\t\t{\n\t\t\t\t  if  (lastParsedPtr_ == NULL)\n\t\t\t\t    lastParsedPtr_\t= scanner();\n\n\t\t\t\t  return(lastParsedPtr_->getType());\n\t\t\t\t}\n\n  //  PURPOSE:  To return the pointer to the old Symbol at that was at the\n  //\tfront of the symbol stream, and then to internally advance to the next\n  //\tSymbol instance (if not already at the end).  No parameters.\n  Symbol*\tadvance\t\t()\n\t\t\t\t{\n\t\t\t\t  Symbol* toReturn\t= lastParsedPtr_;\n\n\t\t\t\t  lastParsedPtr_\t= scanner();\n\t\t\t\t  return(toReturn);\n\t\t\t\t}\n\n};\n\n\nvoid\t\tparseDHow\t(TokenStream&\ttokenizer)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n  while  ( isspace(inputCharStream_.peek()) ) \n  \tinputCharStream_.advance();\n  \t\tswitch(tokenizer);\n  \t\t\tcase (LINE_KEYWORD_SYM);\n  \t\t\t\tdelete(LINE_KEYWORD_SYM);\n  \t\t\t\n  \t\t\tcase (TUMBLE_KEYWORD_SYM);\n  \t\t\t\tdelete(LINE_KEYWORD_SYM);\n  \t\t\t\n  \t\t\tcase (default);\n  \t\t\t\tthrow(\"Expected \\\"line\\\" or \\\"tumble\\\".\");\n  \t\t\t\n\n  //  III.  Finished:\n}\n\n\nvoid\t\tparseDry\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n\n  //  III.  Finished:\n}\n  \n\nvoid\t\tparseItem\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n}\n\nvoid\t\tparseItemList\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n  //  III.  Finished:\n}\n\n\nvoid\t\tparseTemp\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n  //  III.  Finished:\n}\n\n\nvoid\t\tparseWHow\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n  //  III.  Finished:\n}\n\n\nvoid\t\tparseType\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n  //  III.  Finished:\n}\n\nvoid\t\tparseWhat\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n\n}\n\n\nvoid\t\tparseWash\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  // YOUR CODE HERE\n}\n\n\n//  PURPOSE:  To return a 'DirectionCount' corresponding to the directions\n//  \tread for starting non-terminal 'S' (for 'Sentence') from 'tokenizer'.\nvoid\t\tparseSentence\t(TokenStream&\ttokenizer\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Attempt to parse sentence:\n  parseWash(tokenizer);\n\n  if  (tokenizer.peek() != PERIOD_SYM)\n    throw \"Expected \\\".\\\"\";\n\n  delete(tokenizer.advance());\n\n  parseDry(tokenizer);\n\n  if  (tokenizer.peek() != PERIOD_SYM)\n    throw \"Expected \\\".\\\"\";\n\n  delete(tokenizer.advance());\n\n\n  if  (tokenizer.peek() != END_OF_INPUT_SYM)\n    throw \"Expected end-of-input\";\n\n  delete(tokenizer.advance());\n\n  //  III.  Finished:\n}\n\n\n//  PURPOSE:  To return a string with the expression to compute, either from\n//\tthe command line or the keyboard.  'argc' tells how many arguments\n//\twere on the command line and 'argv[]' points to those arguments.\nstd::string\tgetInput\t(int\t\targc,\n\t\t\t\t char*\t\targv[]\n\t\t\t\t)\n{\n  //  I.  Application validity check:\n\n  //  II.  Get input:\n  //  II.A.  Handle command line input:\n  if  (argc > 1)\n    return(std::string(argv[1]));\n\n  //  II.B.  Handle keyboard input:\n  std::string\tinput;\n\n  std::cout << \"Expression to compute: \";\n  std::getline(std::cin,input);\n\n  //  III.  Finished:\n  return(input);\n}\n\n\n//  PURPOSE:  To get, and attempt to compute, the expression.  The expression\n//\tmay either come from the command line or the keyboard.  'argc' tells\n//\thow many arguments were on the command line and 'argv[]' points to\n//\tthose arguments.  Returns 'EXIT_SUCCESS' if the expression was\n//\tsuccessfully parsed and computed or 'EXIT_FAILURE' otherwise.\nint\t\tmain\t\t(int\t\targc,\n\t\t\t\t char*\t\targv[]\n\t\t\t\t)\n{\n  std::string\t\tinput(getInput(argc,argv));\n  InputCharStream\tcharStream(input);\n  int\t\t\tstatus\t= EXIT_SUCCESS;\n\n  try\n  {\n    TokenStream\t\ttokenizer(charStream);\n\n    parseSentence(tokenizer);\n    std::cout << \"Thank you for your laundry order!\" << std::endl;\n\n  }\n  catch  (const char*  messageCPtr\n\t )\n  {\n    std::cerr << messageCPtr << std::endl;\n    status\t= EXIT_FAILURE;\n  }\n\n  return(status);\n}\t","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":685,"column":2},"action":"insert","lines":["#include\t<cstdlib>","#include\t<cstdio>","#include\t<iostream>","#include\t<string>","#include\t<list>","#include\t<map>","","","//  PURPOSE:  To tell the length of a global string.","const int\tTEXT_LEN\t\t= 256;","","","//  PURPOSE:  To represent the different lexemes in the language.","typedef\t\tenum","\t\t{","\t\t  END_OF_INPUT_SYM,","","\t\t  STRING_SYM,","\t\t  NUMBER_SYM,","","\t\t  COMMA_SYM,","\t\t  PERIOD_SYM,","\t\t  BEGIN_PAREN_SYM,","\t\t  END_PAREN_SYM,","","\t\t  WASH_KEYWORD_SYM,","\t\t  DRY_KEYWORD_SYM,","","\t\t  LIGHTS_KEYWORD_SYM,","\t\t  DARKS_KEYWORD_SYM,","\t\t  DELICATES_KEYWORD_SYM,","","\t\t  MACHINE_KEYWORD_SYM,","\t\t  HAND_KEYWORD_SYM,","\t\t  BY_KEYWORD_SYM,","","\t\t  HOT_KEYWORD_SYM,","\t\t  WARM_KEYWORD_SYM,","\t\t  COLD_KEYWORD_SYM,","","\t\t  LINE_KEYWORD_SYM,","\t\t  TUMBLE_KEYWORD_SYM,","","\t\t  TROUSERS_KEYWORD_SYM,","\t\t  SHIRTS_KEYWORD_SYM,","\t\t  UNDERWEAR_KEYWORD_SYM,","\t\t  SHEETS_KEYWORD_SYM","\t\t}","\t\tsymbol_ty;","","//  PURPOSE:  To represent the string delimitor character.","const char\tQUOTE_CHAR\t\t= 0x22;","","","//  PURPOSE:  To represent the decimal point character.","const char\tDECIMAL_PT_CHAR\t\t= '.';","","","//  PURPOSE:  To represent the period character.","const char\tPERIOD_CHAR\t\t= '.';","","","/*  PURPOSE:  To implement an interface that manages the character source."," */","class\tInputCharStream","{","  //  I.  Member vars:","  //  PURPOSE:  To hold the input.","  std::string\t\tinput_;","","  //  PURPOSE:  To hold where the cursor is.","  int\t\t\tindex_;","","  //  II.  Disallowed auto-generated methods:","  ","  //  III.  Protected methods:","protected :","","public:","  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:","  //  PURPOSE:  To","  InputCharStream\t(std::string&\tnewInput","  \t\t\t) :","\t\t\tinput_(newInput),","\t\t\tindex_(0)","\t\t\t{ }","","  //  V.  Accessors:","","  //  VI.  Mutators:","","  //  VII.  Methods that do main and misc work of class:","  //  PURPOSE:  To return the current char, or '\\0' if there are no more.","  //\tNo parameters.","  char\t\tpeek\t()","  \t\t\tconst","\t\t\t{ return","\t\t\t  ( (index_ >= input_.length())","\t\t\t    ? '\\0' : input_[index_]","\t\t\t  );","\t\t\t}","","  //  PURPOSE:  To return 'true' if at eof-of-input, or 'false' otherwise.","  bool\t\tisAtEnd\t()","  \t\t\tconst","\t\t\t{ return(index_ >= input_.length()); }","","  //  PURPOSE:  To advance to the next char (if not already at end).  No","  //\tparameters.  No return value.","  void\t\tadvance\t()","\t\t\t{","\t\t\t  if  (index_ < input_.length())  index_++;","\t\t\t}","","};","","","//  PURPOSE:  To represent a parsed symbol, and any associated data.","class\t\tSymbol","{","  //  I.  Member vars:","  //  PURPOSE:  To tell the type of symbol that '*this' represents.","  symbol_ty\t\t\tsymbol_;","","  //  PURPOSE:  To hold the address of a string associated with '*this' symbol","  //\t(if there is one).","  std::string*\t\t\tstringPtr_;","","  //  PURPOSE:  To hold the number associated with '*this' symbol (if there","  //\tis one).","  double\t\t\tnumber_;","","  //  II.  Disallowed auto-generated methods:","  //  No default constructor:","  Symbol\t\t\t();","","  //  No copy constructor:","  Symbol\t\t\t(const Symbol&","\t\t\t\t);","","  //  No copy assignment op:","  Symbol&\toperator=\t(const Symbol&","\t\t\t\t);","","protected :","  //  III.  Protected methods:","","public :","  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:","  //  PURPOSE:  To initialize '*this' to hold symbol 'newSymbol'.  No return","  //\tvalue.","  Symbol\t\t\t(symbol_ty\tnewSymbol","\t\t\t\t) :","\t\t\t\tsymbol_(newSymbol),","\t\t\t\tstringPtr_(NULL),","\t\t\t\tnumber_(0.0)","\t\t\t\t{ }","","  //  PURPOSE:  To initialize '*this' to hold string 'newString'.  No return","  //\tvalue.","  Symbol\t\t\t(const std::string&\tnewString","  \t\t\t\t) :","\t\t\t\tsymbol_(STRING_SYM),","\t\t\t\tstringPtr_(new std::string(newString)),","\t\t\t\tnumber_(0.0)","\t\t\t\t{ }","\t\t\t\t","  //  PURPOSE:  To initialize '*this' to hold number 'newNumber'.  No return","  //\tvalue.","  Symbol\t\t\t(double\tnewNumber","\t\t\t\t) :","\t\t\t\tsymbol_(NUMBER_SYM),","\t\t\t\tstringPtr_(NULL),","\t\t\t\tnumber_(newNumber)","\t\t\t\t{ }","","  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return","  //\tvalue.","  ~Symbol\t\t\t()","\t\t\t\t{","\t\t\t\t  delete(stringPtr_);","\t\t\t\t}","","  //  V.  Accessors:","  //  PURPOSE:  To return the type associated with '*this' Symbol.  No","  //  \tparameters.","  symbol_ty\tgetType\t\t()","\t\t\t\tconst","\t\t\t\t{ return(symbol_); }","","  //  PURPOSE:  To return a reference to the string stored at '*this' Symbol,","  //\tor a reference to the empty string if '*this' is not a string.","  const std::string&","\t\tgetString\t()","\t\t\t\tconst","\t\t\t\t{","\t\t\t\t  static std::string\tempty(\"\");","","\t\t\t\t  return( (stringPtr_ == NULL)","\t\t\t\t  \t  ? empty","\t\t\t\t\t  : *stringPtr_","\t\t\t\t\t);","\t\t\t\t}","","  //  PURPOSE:  To return the number stored at '*this' Symbol, or '0' if","  //\t'*this' does not represent a number.","  double\tgetNumber\t()","\t\t\t\tconst","\t\t\t\t{ return(number_); }","","};","","","//  PURPOSE:  To hold a shared global array of characters.","char\t\t\t\ttext[TEXT_LEN];","","","//  PURPOSE:  To implement an interface that gathers characters into lexemes.","class\tTokenStream","{","  //  I.  Member vars:","  //  PURPOSE:  To hold the source of the character input.","  InputCharStream&\tinputCharStream_;","","  //  PURPOSE:  To hold the lastest lexeme parsed.","  Symbol*\t   \tlastParsedPtr_;","","  //  PURPOSE:  To hold the keyword string to symbol_ty mapping.","  std::map<std::string,symbol_ty>","\t\t\tkeywordToSymbolTMap_;","","  //  II.  Disallowed auto-generated methods:","  //  No default constructor:","  TokenStream\t\t();","","  //  No copy constructor:","  TokenStream\t\t(const TokenStream&","\t\t\t);","","  //  No copy assignment op:","  TokenStream&\t\toperator=","\t\t\t(const TokenStream&","\t\t\t);","","protected :","  //  III.  Protected methods:","  //  PURPOSE:  To return a pointer representing a scanned string constant.","  //\tNo parameters.","  Symbol*\tscanString\t()","\t\t\t\t{","\t\t\t\t  std::string\tlex(\"\");","\t\t\t\t  bool\t\thaveFoundEnd\t= false;","","\t\t\t\t  //  Advance past first quote:","\t\t\t\t  inputCharStream_.advance();","","\t\t\t\t  while  ( !inputCharStream_.isAtEnd() )","\t\t\t\t  {","\t\t\t\t    char\tc = inputCharStream_.peek();","","\t\t\t\t    inputCharStream_.advance();","","\t\t\t\t    if  (c == QUOTE_CHAR)","\t\t\t\t    {","\t\t\t\t      haveFoundEnd\t= true;","\t\t\t\t      break;","\t\t\t\t    }","","\t\t\t\t    lex\t+= c;","\t\t\t\t  }","","\t\t\t\t  if  (!haveFoundEnd)","\t\t\t\t    throw \"Non-terminated string constant\";","","\t\t\t\t  return(new Symbol(lex));","\t\t\t\t}","","  //  PURPOSE:  To return a pointer representing a scanned number.  No","  //\tparameters.","  Symbol*   \tscanNumber\t()","\t\t\t\t{","\t\t\t\t  bool\t\thaveSeenDecimalPt\t= false;","\t\t\t\t  std::string\tlex(\"\");","\t\t\t\t  char\t\tc;","","\t\t\t\t  while  ( c = inputCharStream_.peek(),","\t\t\t\t  \t   isdigit(c)","\t\t\t\t  \t   || ( (c == DECIMAL_PT_CHAR)","\t\t\t\t\t\t&&","\t\t\t\t\t\t!haveSeenDecimalPt","\t\t\t\t\t      )","\t\t\t\t  \t )","\t\t\t\t  {","\t\t\t\t    lex\t\t       += c;","\t\t\t\t    haveSeenDecimalPt\t= (c==DECIMAL_PT_CHAR);","\t\t\t\t    inputCharStream_.advance();","\t\t\t\t  }","","\t\t\t\t  return(new Symbol(atof(lex.c_str())));","\t\t\t\t}","","","  //  PURPOSE:  To return a pointer to a Symbol instance representing an","  //\taddress.","  Symbol*\tscanIdentifier\t()","  \t\t\t\t{","\t\t\t\t  std::string\tlex(\"\");","\t\t\t\t  char\t\tc;","","\t\t\t\t  lex\t+= tolower(inputCharStream_.peek());","\t\t\t\t  inputCharStream_.advance();","","\t\t\t\t  while  (c = inputCharStream_.peek(),","\t\t\t\t  \t   isalnum(c) || (c == '_')","\t\t\t\t  \t )","\t\t\t\t  {","\t\t\t\t    lex\t\t       += tolower(c);","\t\t\t\t    inputCharStream_.advance();","\t\t\t\t  }","","\t\t\t\t  std::map<std::string,symbol_ty>::iterator","\t\t\t\t    iter = keywordToSymbolTMap_.find(lex);","","\t\t\t\t  if  (iter != keywordToSymbolTMap_.end())","\t\t\t\t    return(new Symbol(iter->second));","","\t\t\t\t  std::string\tkeywords;","\t\t\t\t  bool\t\tisFirst\t= true;","","\t\t\t\t  for  (iter  = keywordToSymbolTMap_.begin();","\t\t\t\t        iter != keywordToSymbolTMap_.end();","\t\t\t\t\titer++","\t\t\t\t       )","\t\t\t\t  {","\t\t\t\t    if  (isFirst)","\t\t\t\t      isFirst\t = false;","\t\t\t\t    else","\t\t\t\t      keywords\t+= \", \";","","\t\t\t\t    keywords += iter->first;","\t\t\t\t  }","","\t\t\t\t  snprintf","\t\t\t\t\t(text,TEXT_LEN,","\t\t\t\t\t \"Expected one of %s, not %s\",","\t\t\t\t\t keywords.c_str(),lex.c_str()","\t\t\t\t\t);","\t\t\t\t  throw text;","\t\t\t\t}","","  //  PURPOSE:  To return a pointer representing a scanned Symbol, or to return","  //\t'new Symbol(END_OF_INPUT_SYM)' if the '*this' is at the end-of-input.","  //\tNo parameters.","  Symbol*\tscanner\t\t()","  \t\t\t\t{","\t\t\t\t  while  ( isspace(inputCharStream_.peek()) )","\t\t\t\t    inputCharStream_.advance();","","\t\t\t\t  if  ( inputCharStream_.isAtEnd() )","\t\t\t\t    return( new Symbol(END_OF_INPUT_SYM) );","","\t\t\t\t  if  ( inputCharStream_.peek() == QUOTE_CHAR )","\t\t\t\t    return( scanString() );","","\t\t\t\t  if  ( isdigit(inputCharStream_.peek()) )","\t\t\t\t    return( scanNumber() );","","\t\t\t\t  if  ( isalpha(inputCharStream_.peek())","\t\t\t\t        || (inputCharStream_.peek() == '_')","\t\t\t\t      )","\t\t\t\t    return( scanIdentifier() );","","\t\t\t\t  char\t  ch\t    = inputCharStream_.peek();","\t\t\t\t  Symbol* symbolPtr = NULL;","","\t\t\t\t  inputCharStream_.advance();","","\t\t\t\t  switch  (ch)","\t\t\t\t  {","\t\t\t\t  case '(' :","\t\t\t\t    symbolPtr\t= new Symbol(BEGIN_PAREN_SYM);","\t\t\t\t    break;","","\t\t\t\t  case ')' :","\t\t\t\t    symbolPtr\t= new Symbol(END_PAREN_SYM);","\t\t\t\t    break;","","\t\t\t\t  case ',' :","\t\t\t\t    symbolPtr\t= new Symbol(COMMA_SYM);","\t\t\t\t    break;","","\t\t\t\t  case PERIOD_CHAR :","\t\t\t\t    symbolPtr\t= new Symbol(PERIOD_SYM);","\t\t\t\t    break;","","\t\t\t\t  default :","\t\t\t\t    throw \"Unexpected character in input\";","\t\t\t\t  }","","\t\t\t\t  return(symbolPtr);","\t\t\t\t}","","public :","  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:","  //  PURPOSE:  To initialize '*this' to tokenize given characters read from","  //  \t'newInputCharStream'.  No parameters.","  TokenStream\t\t\t(InputCharStream&\tnewInputCharStream","\t\t\t\t) :","\t\t\t\tinputCharStream_(newInputCharStream),","\t\t\t\tlastParsedPtr_(NULL)","\t\t\t\t{","\t\t\t\t  keywordToSymbolTMap_[\".\"]","\t\t\t\t\t= PERIOD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"wash\"]","\t\t\t\t\t= WASH_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"dry\"]","\t\t\t\t\t= DRY_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"lights\"]","\t\t\t\t\t= LIGHTS_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"darks\"]","\t\t\t\t\t= DARKS_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"delicates\"]","\t\t\t\t\t= DELICATES_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"machine\"]","\t\t\t\t\t= MACHINE_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"hand\"]","\t\t\t\t\t= HAND_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"by\"]","\t\t\t\t\t= BY_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"hot\"]","\t\t\t\t\t= HOT_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"warm\"]","\t\t\t\t\t= WARM_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"cold\"]","\t\t\t\t\t= COLD_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"line\"]","\t\t\t\t\t= LINE_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"tumble\"]","\t\t\t\t\t= TUMBLE_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"trousers\"]","\t\t\t\t\t= TROUSERS_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"shirts\"]","\t\t\t\t\t= SHIRTS_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"underwear\"]","\t\t\t\t\t= UNDERWEAR_KEYWORD_SYM;","\t\t\t\t  keywordToSymbolTMap_[\"sheets\"]","\t\t\t\t\t= SHEETS_KEYWORD_SYM;","\t\t\t\t  advance();","\t\t\t\t}","","  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No return","  //\tvalue.","  ~TokenStream\t\t\t()","\t\t\t\t{ }","","  //  V.  Accessors:","","  //  VI.  Mutators:","","  //  VII.  Methods that do main and misc work of class:","  //  PURPOSE:  To return the 'symbol_ty' of the 'Symbol' instance that is next","  //\tin the symbol stream.  No parameters.","  symbol_ty   \tpeek\t\t()","\t\t\t\t{","\t\t\t\t  if  (lastParsedPtr_ == NULL)","\t\t\t\t    lastParsedPtr_\t= scanner();","","\t\t\t\t  return(lastParsedPtr_->getType());","\t\t\t\t}","","  //  PURPOSE:  To return the pointer to the old Symbol at that was at the","  //\tfront of the symbol stream, and then to internally advance to the next","  //\tSymbol instance (if not already at the end).  No parameters.","  Symbol*\tadvance\t\t()","\t\t\t\t{","\t\t\t\t  Symbol* toReturn\t= lastParsedPtr_;","","\t\t\t\t  lastParsedPtr_\t= scanner();","\t\t\t\t  return(toReturn);","\t\t\t\t}","","};","","","void\t\tparseDHow\t(TokenStream&\ttokenizer)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","  while  ( isspace(inputCharStream_.peek()) ) ","  \tinputCharStream_.advance();","  \t\tswitch(tokenizer);","  \t\t\tcase (LINE_KEYWORD_SYM);","  \t\t\t\tdelete(LINE_KEYWORD_SYM);","  \t\t\t","  \t\t\tcase (TUMBLE_KEYWORD_SYM);","  \t\t\t\tdelete(LINE_KEYWORD_SYM);","  \t\t\t","  \t\t\tcase (default);","  \t\t\t\tthrow(\"Expected \\\"line\\\" or \\\"tumble\\\".\");","  \t\t\t","","  //  III.  Finished:","}","","","void\t\tparseDry\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","","  //  III.  Finished:","}","  ","","void\t\tparseItem\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","}","","void\t\tparseItemList\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","  //  III.  Finished:","}","","","void\t\tparseTemp\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","  //  III.  Finished:","}","","","void\t\tparseWHow\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","  //  III.  Finished:","}","","","void\t\tparseType\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","  //  III.  Finished:","}","","void\t\tparseWhat\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","","}","","","void\t\tparseWash\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  // YOUR CODE HERE","}","","","//  PURPOSE:  To return a 'DirectionCount' corresponding to the directions","//  \tread for starting non-terminal 'S' (for 'Sentence') from 'tokenizer'.","void\t\tparseSentence\t(TokenStream&\ttokenizer","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Attempt to parse sentence:","  parseWash(tokenizer);","","  if  (tokenizer.peek() != PERIOD_SYM)","    throw \"Expected \\\".\\\"\";","","  delete(tokenizer.advance());","","  parseDry(tokenizer);","","  if  (tokenizer.peek() != PERIOD_SYM)","    throw \"Expected \\\".\\\"\";","","  delete(tokenizer.advance());","","","  if  (tokenizer.peek() != END_OF_INPUT_SYM)","    throw \"Expected end-of-input\";","","  delete(tokenizer.advance());","","  //  III.  Finished:","}","","","//  PURPOSE:  To return a string with the expression to compute, either from","//\tthe command line or the keyboard.  'argc' tells how many arguments","//\twere on the command line and 'argv[]' points to those arguments.","std::string\tgetInput\t(int\t\targc,","\t\t\t\t char*\t\targv[]","\t\t\t\t)","{","  //  I.  Application validity check:","","  //  II.  Get input:","  //  II.A.  Handle command line input:","  if  (argc > 1)","    return(std::string(argv[1]));","","  //  II.B.  Handle keyboard input:","  std::string\tinput;","","  std::cout << \"Expression to compute: \";","  std::getline(std::cin,input);","","  //  III.  Finished:","  return(input);","}","","","//  PURPOSE:  To get, and attempt to compute, the expression.  The expression","//\tmay either come from the command line or the keyboard.  'argc' tells","//\thow many arguments were on the command line and 'argv[]' points to","//\tthose arguments.  Returns 'EXIT_SUCCESS' if the expression was","//\tsuccessfully parsed and computed or 'EXIT_FAILURE' otherwise.","int\t\tmain\t\t(int\t\targc,","\t\t\t\t char*\t\targv[]","\t\t\t\t)","{","  std::string\t\tinput(getInput(argc,argv));","  InputCharStream\tcharStream(input);","  int\t\t\tstatus\t= EXIT_SUCCESS;","","  try","  {","    TokenStream\t\ttokenizer(charStream);","","    parseSentence(tokenizer);","    std::cout << \"Thank you for your laundry order!\" << std::endl;","","  }","  catch  (const char*  messageCPtr","\t )","  {","    std::cerr << messageCPtr << std::endl;","    status\t= EXIT_FAILURE;","  }","","  return(status);","}\t"],"id":1}]]},"ace":{"folds":[],"scrolltop":9245,"scrollleft":0,"selection":{"start":{"row":685,"column":2},"end":{"row":685,"column":2},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":659,"state":"start","mode":"ace/mode/text"}},"timestamp":1505788231409}