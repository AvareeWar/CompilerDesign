{"filter":false,"title":"tinyPascal.y","tooltip":"/FinalProject/tinyPascal.y","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":612,"column":1},"action":"remove","lines":["%{","","/*-------------------------------------------------------------------------*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t\ttinyPascal.y\t\t\t\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t    This file defines a parser used to parser a subset of\t---*"," *---\tPascal.\t\t\t\t\t\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t----\t----\t----\t----\t----\t----\t----\t----\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\tVersion 1a\t\t2017 June 1\t\tJoseph Phillips\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *-------------------------------------------------------------------------*/","","/*-------------------------------------------------------------------------*","","\t\t\t\tCompile with:","bison -d --debug tinyPascal.y","g++ -c tinyPascal.tab.c -g","flex -o tinyPascal.cpp tinyPascal.lex ","g++ -c tinyPascal.cpp -g","g++ -o tinyPascal tinyPascal.tab.o tinyPascal.o",""," *-------------------------------------------------------------------------*/","","","#include\t\"tinyPascal.h\"","","%}","","%union","{","  std::list<std::string*>*\tidentifierPtrListPtr_;","  Node*\t\t\t\tnodePtr_;","  StatementListNode*\t\tstatementListNodePtr_;","  std::string*\t\t\tstrPtr_;","  bool\t\t\t\tbool_;","  int\t\t\t\tinteger_;","  float\t\t\t\treal_;","  char*\t\t\t\tcharPtr_;","  simpleType_ty\t\t\tsimpleType_;","};","","%start\t\tprogram","","%nonassoc\tPROGRAM VAR BEGIN_ END_","%nonassoc\tIF THEN FOR TO DOWNTO DO WHILE REPEAT UNTIL WRITE WRITELN","%nonassoc\tELSE","%nonassoc\tCOMMA SEMICOLON COLON PERIOD","%left\t\tLESSER LESSER_EQUAL GREATER GREATER_EQUAL EQUAL NOT_EQUAL","%left\t\tPLUS MINUS OR","%right\t\tSTAR INT_DIV REAL_DIV AND","%nonassoc\tNOT","%nonassoc\tASSIGN","%nonassoc\t\t\t\tBEGIN_PAREN END_PAREN","%token<strPtr_>\t\t\t\tIDENTIFIER","%token<simpleType_>\t\t\tSIMPLE_TYPE","%token<bool_>\t\t\t\tBOOLEAN","%token<integer_>\t\t\tINTEGER","%token<real_>\t\t\t\tREAL","%token<charPtr_>\t\t\tSTRING","%type<statementListNodePtr_>\t\tprogram","%type<identifierPtrListPtr_>\t\tvarList","%type<statementListNodePtr_>\t\tbeginBlock","%type<statementListNodePtr_>\t\tstatementList","%type<nodePtr_>\t\t\t\tstatement","%type<nodePtr_>\t\t\t\texpression","%type<nodePtr_>\t\t\t\tsimpleExpression","%type<nodePtr_>\t\t\t\tterm","%type<nodePtr_>\t\t\t\tfactor","%%","","program\t\t:\tPROGRAM","\t\t\tIDENTIFIER","\t\t\tSEMICOLON","\t\t\toptionalVarDeclaration","\t\t\tbeginBlock","\t\t\tPERIOD","\t\t\t{","\t\t\t  programRoot = $$ = $5;","\t\t\t};","","optionalVarDeclaration:\tVAR","\t\t\tvarDeclarationList","\t\t\t{","\t\t\t}","\t\t|\t","\t\t\t{","\t\t\t   // Lambda","\t\t\t};","","varDeclarationList :\tvarDeclarationList","\t\t   \tvarDeclarationSeq","\t\t\t{","\t\t\t}","\t\t|","\t\t\t{","\t\t\t   // Lambda","\t\t\t};","","varDeclarationSeq :\tvarList","\t\t  \tCOLON","\t\t\tSIMPLE_TYPE","\t\t\tSEMICOLON","\t\t\t{","\t\t\t  std::list<std::string*>::iterator iter = $1->begin();","\t\t\t  std::list<std::string*>::iterator end  = $1->end();","","\t\t\t  for  ( ; iter != end;  iter++)","\t\t\t  {","\t\t\t    symbolTable.declare(**iter,$3);","\t\t\t    delete(*iter);","\t\t\t    *iter\t= NULL;","\t\t\t  }","","\t\t\t};","","varList :\t\tvarList","\t\t\tCOMMA","\t\t\tIDENTIFIER","\t\t\t{","\t\t\t  $$ = $1;","\t\t\t  $$->push_back($3);","\t\t\t}","\t\t|\tIDENTIFIER","\t\t\t{","\t\t\t  $$ = new std::list<std::string*>;","\t\t\t  $$->push_back($1);","\t\t\t};","","beginBlock :\t\tBEGIN_","\t   \t\tstatementList","\t\t\tEND_","\t\t\t{","\t\t\t  $$ = $2;","\t\t\t}","\t\t|\tBEGIN_","\t   \t\tstatementList","\t      \t\tSEMICOLON","\t\t\tEND_","\t\t\t{","\t\t\t  $$ = $2;","\t\t\t};","","statementList :\t\tstatementList","\t      \t\tSEMICOLON","\t      \t\tstatement","\t\t\t{","\t\t\t  $$\t= $1;","","\t\t\t  if  ($3 != NULL)","\t\t\t    $$->append($3);","\t\t\t}","\t\t|\tstatement","\t\t\t{","\t\t\t  $$\t= new StatementListNode;","","\t\t\t  if  ($1 != NULL)","\t\t\t    $$->append($1);","\t\t\t};","","statement :\t\tbeginBlock","\t  \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tIF","\t\t\texpression","\t\t\tTHEN","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new IfNode($2,$4);","\t\t\t}","\t\t|\tIF","\t\t\texpression","\t\t\tTHEN","\t\t\tstatement","\t\t\tELSE","\t\t\tstatement\t%prec ELSE","\t\t\t{","\t\t\t  $$\t= new IfNode($2,$4,$6);","\t\t\t}","\t\t|\tFOR","\t\t\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\tTO","\t\t\texpression","\t\t\tDO","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new ForNode","\t\t\t\t\t(new VariableNode(*$2),","\t\t\t\t\t $4,","\t\t\t\t\t $6,","\t\t\t\t\t $8,","\t\t\t\t\t +1","\t\t\t\t\t);","\t\t\t  delete($2);","\t\t\t}","\t\t|\tFOR","\t\t\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\tDOWNTO","\t\t\texpression","\t\t\tDO","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new ForNode","\t\t\t\t\t(new VariableNode(*$2),","\t\t\t\t\t $4,","\t\t\t\t\t $6,","\t\t\t\t\t $8,","\t\t\t\t\t -1","\t\t\t\t\t);","\t\t\t  delete($2);","\t\t\t}","\t\t|\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\t{","\t\t\t  $$\t= new AssignmentNode(new VariableNode(*$1),$3);","\t\t\t  delete($1);","\t\t\t}","\t\t|\tWRITELN","\t\t\t{","\t\t\t  $$\t= new WriteNode(true);","\t\t\t}","\t\t|\tWRITE","\t\t\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= new WriteNode(false,$3);","\t\t\t};","\t\t|\tWRITELN","\t\t\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= new WriteNode(true,$3);","\t\t\t};","","expression :\t\tsimpleExpression","\t   \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tLESSER","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(LESSER_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tLESSER_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(LESSER_EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tGREATER","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(GREATER_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tGREATER_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(GREATER_EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tEQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tNOT_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(NOT_EQUAL_CO,$1,$3);","\t\t\t};","","simpleExpression :\tterm","\t   \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tPLUS","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(ADD_BMO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tMINUS","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(SUBTRACT_BMO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tOR","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryLogicOpNode(OR_BLO,$1,$3);","\t\t\t};","","term\t:\t\tfactor","\t\t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tterm","\t\t\tSTAR","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(MULTIPLY_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tINT_DIV","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(INT_DIVIDE_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tREAL_DIV","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(REAL_DIVIDE_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tAND","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryLogicOpNode(AND_BLO,$1,$3);","\t\t\t};","","factor :\t\tIDENTIFIER","       \t\t\t{","\t\t\t  $$\t= new VariableNode(*$1);","\t\t\t  delete($1);","\t\t\t}","\t\t|\tBOOLEAN","\t\t\t{","\t\t\t  $$\t= new BooleanConstantNode($1);","\t\t\t}","\t\t|\tINTEGER","\t\t\t{","\t\t\t  $$\t= new IntegerConstantNode($1);","\t\t\t}","\t\t|\tREAL","\t\t\t{","\t\t\t  $$\t= new RealConstantNode($1);","\t\t\t}","\t\t|\tSTRING","\t\t\t{","\t\t\t  $$\t= new StringConstantNode($1);","\t\t\t}","\t\t|\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= $2;","\t\t\t};","\t\t\t","","%%","","","","//  PURPOSE:  To hold the address of the root of the parse tree.","Node*\t\tprogramRoot\t= NULL;","","","int\t\tyyerror\t\t(const char*\tcPtr)","{","  printf(\"%s, sorry!\\n\",cPtr);","  return(0);","}","","","int\t\tyylex\t\t();","","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'binaryLogicOp_ty' value.","const char*\tbinaryLogicOpName[]","\t\t\t\t= { \"\",","\t\t\t\t    \"or\",","\t\t\t\t    \"and\"","\t\t\t\t  };","","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'binaryMathOp_ty' value.","const char*\tbinaryMathOpName[]","      \t\t\t\t= { \"\",","\t\t\t\t    \"add\",","\t\t\t\t    \"sub\",","\t\t\t\t    \"mul\",","\t\t\t\t    \"div\"","\t\t\t\t  };","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'comparisonOp_ty' value.","const char*\tcomparisonOpName[]","      \t\t\t\t= { \"\",","\t\t\t\t    \"lesser\",","\t\t\t\t    \"lesserEqual\",","\t\t\t\t    \"greater\",","\t\t\t\t    \"greaterEqual\",","\t\t\t\t    \"equal\",","\t\t\t\t    \"not_equal\"","\t\t\t\t  };","","//  PURPOSE:  To hold the names of boolean constants.","const char*\tbooleanConstName[]","\t\t\t\t= {\"false\", \"true\"};","","","//  PURPOSE:  To point to the stream to which output should be written","std::ofstream*\toutputStreamPtr\t= NULL;","","//  PURPOSE:  To hold the next label number to use:","int\t\tLabelMention::nextLabelId__","\t\t\t\t= 0;","","","//  PURPOSE:  To output '*toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const LabelMention*\ttoPrint","\t\t\t\t)","{","  os << LABEL_COMMON_PREFIX << toPrint->getId() << LABEL_COMMON_POSTFIX;","  return(os);","}","","","//  PURPOSE:  To output 'toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const LabelMention&\ttoPrint","\t\t\t\t)","{","  os << LABEL_COMMON_PREFIX << toPrint.getId() << LABEL_COMMON_POSTFIX;","  return(os);","}","","","//  PURPOSE:  To hold the next auto-generated variable number to use:","int\t\tVariableMention::nextAutoVarId__","\t\t\t\t= RETURN_VAR + 1;","","","//  PURPOSE:  To output '*toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const VariableMention*\ttoPrint","\t\t\t\t)","{","  os << VAR_PREFIX_CHAR << toPrint->getName();","  return(os);","}","","","//  PURPOSE:  To output 'toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const VariableMention&\ttoPrint","\t\t\t\t)","{","  os << VAR_PREFIX_CHAR << toPrint.getName();","}","","","","//  PURPOSE:  To hold defintions of symbols (e.g. variables)","SymbolTable\tsymbolTable;","","","//  PURPOSE:  To release the resources of '*this'.  No parameters.  No return","//\tvalue.","Node::~Node\t\t\t()","\t\t\t\t{ }","","","//  PURPOSE:  To make '*this' mention the variable named 'cPtr'.","//  \tNo parameters.  No return value.","VariableMention::VariableMention(const char*\tcPtr","  \t\t\t\t) :","\t\t\t\tname_(NULL)","\t\t\t\t{","\t\t\t\t  std::stringstream\tstrm;","","\t\t\t\t  strm << symbolTable.getOffset(cPtr);","\t\t\t\t  name_\t= strm.str();","\t\t\t\t}","","//  PURPOSE:  To make '*this' mention the variable named 'newName'.","//  \tNo parameters.  No return value.","VariableMention::VariableMention(const std::string&\tnewName","\t\t\t\t) :","\t\t\t\tname_(newName)","\t\t\t\t{","\t\t\t\t  std::stringstream\tstrm;","","\t\t\t\t  strm << symbolTable.getOffset(newName);","\t\t\t\t  name_\t= strm.str();","\t\t\t\t}","","//  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is","//  \tset to the type that the code generated by '*this' node returns (or","//\t to 'NO_TYPE_ST' if it does not return a value).  Returns the address","//\t of a VariableMention that the code generated by '*this' node updates","//\t(or 'NULL' if there is no such variable).","VariableMention*","\t\tVariableNode::compile","\t\t\t\t(simpleType_ty&\tsimpleType","\t\t\t\t)","{","  //  Set 'simpleType' to the type returned by 'symbolTable.getType()' when","  //\tyou give it the name of the variable.","  //  If this type is 'NO_TYPE_ST' then do:","  //","  //\tthrow \"Undeclared variable\";","  //","  //  otherwise, set 'varPtr_' to a new VariableMention for this variable","  //\t(just say 'new VariableMention(getName()') and return 'varPtr_'.","  simpleType = symbolTable.getType(name_);","  if (simpleType == NO_TYPE_ST){","  \tthrow(\"Undeclared variable\");","  }","  else {","  \tvarPtr_ = new VariableMention(getName());","  }","  \treturn (varPtr_);","  ","  \t\t// <-- change that NULL","}","","","int\t\tmain\t\t(int\t\targc,","\t\t\t\t char*\t\targv[]","\t\t\t\t)","{","  //  I.  Application validity check:","  if  (argc < 2)","  {","    fprintf(stderr,\"Usage:\\t%s <pascalProg> <assemblyOutFile>\\n\",argv[0]);","    exit(EXIT_FAILURE);","  }","","  //  II.  Parse and execute program:","  //  II.A.  Initialize files:","  const char*\tpascalFilepath\t= argv[1];","  const char*\tassemblyFilepath= argv[2];","  std::ofstream\toutput(assemblyFilepath);","","  outputStreamPtr\t= &output;","","  if  ( (yyin = fopen(pascalFilepath,\"r\")) == NULL )","  {","    fprintf(stderr,\"Error opening %s.\\n\",pascalFilepath);","    exit(EXIT_FAILURE);","  }","","  if  ( !output.is_open() )","  {","    fprintf(stderr,\"Error opening %s.\\n\",assemblyFilepath);","    fclose(yyin);","    exit(EXIT_FAILURE);","  }","","  //  II.B.  Attempt to parse and assemble 'filename':","  int\tstatus\t= EXIT_SUCCESS;","","  try","  {","    yyparse();","","    if  (programRoot != NULL)","    {","      simpleType_ty\tsimpleType;","      VariableMention*\tnodePtr\t= programRoot->compile(simpleType);","","      programRoot->writeAssembly(output);","","      if  (nodePtr == NULL)","        output << \"  load \" << RETURN_VAR_NAME","\t       << \",\"  << RETURN_VAR","\t       << std::endl;","      else","      {","        output << \"  copy \" << RETURN_VAR_NAME","\t       << \",\" << *nodePtr","\t       << std::endl;","      }","","      output << \"  stopWSuccess\" << std::endl;","    }","","  }","  catch  (const char* cPtr)","  {","    fprintf(stderr,\"Error: %s\\n\",cPtr);","    status\t= EXIT_FAILURE;","  }","","  //  II.C.  Clean up:","  delete(programRoot);","  output.close();","  fclose(yyin);","","  //  III.  Finished:","  return(status);","}"],"id":4},{"start":{"row":0,"column":0},"end":{"row":612,"column":1},"action":"insert","lines":["%{","","/*-------------------------------------------------------------------------*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t\ttinyPascal.y\t\t\t\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t    This file defines a parser used to parser a subset of\t---*"," *---\tPascal.\t\t\t\t\t\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t----\t----\t----\t----\t----\t----\t----\t----\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\tVersion 1a\t\t2017 June 1\t\tJoseph Phillips\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *-------------------------------------------------------------------------*/","","/*-------------------------------------------------------------------------*","","\t\t\t\tCompile with:","bison -d --debug tinyPascal.y","g++ -c tinyPascal.tab.c -g","flex -o tinyPascal.cpp tinyPascal.lex ","g++ -c tinyPascal.cpp -g","g++ -o tinyPascal tinyPascal.tab.o tinyPascal.o",""," *-------------------------------------------------------------------------*/","","","#include\t\"tinyPascal.h\"","","%}","","%union","{","  std::list<std::string*>*\tidentifierPtrListPtr_;","  Node*\t\t\t\tnodePtr_;","  StatementListNode*\t\tstatementListNodePtr_;","  std::string*\t\t\tstrPtr_;","  bool\t\t\t\tbool_;","  int\t\t\t\tinteger_;","  float\t\t\t\treal_;","  char*\t\t\t\tcharPtr_;","  simpleType_ty\t\t\tsimpleType_;","};","","%start\t\tprogram","","%nonassoc\tPROGRAM VAR BEGIN_ END_","%nonassoc\tIF THEN FOR TO DOWNTO DO WHILE REPEAT UNTIL WRITE WRITELN","%nonassoc\tELSE","%nonassoc\tCOMMA SEMICOLON COLON PERIOD","%left\t\tLESSER LESSER_EQUAL GREATER GREATER_EQUAL EQUAL NOT_EQUAL","%left\t\tPLUS MINUS OR","%right\t\tSTAR INT_DIV REAL_DIV AND","%nonassoc\tNOT","%nonassoc\tASSIGN","%nonassoc\t\t\t\tBEGIN_PAREN END_PAREN","%token<strPtr_>\t\t\t\tIDENTIFIER","%token<simpleType_>\t\t\tSIMPLE_TYPE","%token<bool_>\t\t\t\tBOOLEAN","%token<integer_>\t\t\tINTEGER","%token<real_>\t\t\t\tREAL","%token<charPtr_>\t\t\tSTRING","%type<statementListNodePtr_>\t\tprogram","%type<identifierPtrListPtr_>\t\tvarList","%type<statementListNodePtr_>\t\tbeginBlock","%type<statementListNodePtr_>\t\tstatementList","%type<nodePtr_>\t\t\t\tstatement","%type<nodePtr_>\t\t\t\texpression","%type<nodePtr_>\t\t\t\tsimpleExpression","%type<nodePtr_>\t\t\t\tterm","%type<nodePtr_>\t\t\t\tfactor","%%","","program\t\t:\tPROGRAM","\t\t\tIDENTIFIER","\t\t\tSEMICOLON","\t\t\toptionalVarDeclaration","\t\t\tbeginBlock","\t\t\tPERIOD","\t\t\t{","\t\t\t  programRoot = $$ = $5;","\t\t\t};","","optionalVarDeclaration:\tVAR","\t\t\tvarDeclarationList","\t\t\t{","\t\t\t}","\t\t|\t","\t\t\t{","\t\t\t   // Lambda","\t\t\t};","","varDeclarationList :\tvarDeclarationList","\t\t   \tvarDeclarationSeq","\t\t\t{","\t\t\t}","\t\t|","\t\t\t{","\t\t\t   // Lambda","\t\t\t};","","varDeclarationSeq :\tvarList","\t\t  \tCOLON","\t\t\tSIMPLE_TYPE","\t\t\tSEMICOLON","\t\t\t{","\t\t\t  std::list<std::string*>::iterator iter = $1->begin();","\t\t\t  std::list<std::string*>::iterator end  = $1->end();","","\t\t\t  for  ( ; iter != end;  iter++)","\t\t\t  {","\t\t\t    symbolTable.declare(**iter,$3);","\t\t\t    delete(*iter);","\t\t\t    *iter\t= NULL;","\t\t\t  }","","\t\t\t};","","varList :\t\tvarList","\t\t\tCOMMA","\t\t\tIDENTIFIER","\t\t\t{","\t\t\t  $$ = $1;","\t\t\t  $$->push_back($3);","\t\t\t}","\t\t|\tIDENTIFIER","\t\t\t{","\t\t\t  $$ = new std::list<std::string*>;","\t\t\t  $$->push_back($1);","\t\t\t};","","beginBlock :\t\tBEGIN_","\t   \t\tstatementList","\t\t\tEND_","\t\t\t{","\t\t\t  $$ = $2;","\t\t\t}","\t\t|\tBEGIN_","\t   \t\tstatementList","\t      \t\tSEMICOLON","\t\t\tEND_","\t\t\t{","\t\t\t  $$ = $2;","\t\t\t};","","statementList :\t\tstatementList","\t      \t\tSEMICOLON","\t      \t\tstatement","\t\t\t{","\t\t\t  $$\t= $1;","","\t\t\t  if  ($3 != NULL)","\t\t\t    $$->append($3);","\t\t\t}","\t\t|\tstatement","\t\t\t{","\t\t\t  $$\t= new StatementListNode;","","\t\t\t  if  ($1 != NULL)","\t\t\t    $$->append($1);","\t\t\t};","","statement :\t\tbeginBlock","\t  \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tIF","\t\t\texpression","\t\t\tTHEN","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new IfNode($2,$4);","\t\t\t}","\t\t|\tIF","\t\t\texpression","\t\t\tTHEN","\t\t\tstatement","\t\t\tELSE","\t\t\tstatement\t%prec ELSE","\t\t\t{","\t\t\t  $$\t= new IfNode($2,$4,$6);","\t\t\t}","\t\t|\tFOR","\t\t\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\tTO","\t\t\texpression","\t\t\tDO","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new ForNode","\t\t\t\t\t(new VariableNode(*$2),","\t\t\t\t\t $4,","\t\t\t\t\t $6,","\t\t\t\t\t $8,","\t\t\t\t\t +1","\t\t\t\t\t);","\t\t\t  delete($2);","\t\t\t}","\t\t|\tFOR","\t\t\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\tDOWNTO","\t\t\texpression","\t\t\tDO","\t\t\tstatement","\t\t\t{","\t\t\t  $$\t= new ForNode","\t\t\t\t\t(new VariableNode(*$2),","\t\t\t\t\t $4,","\t\t\t\t\t $6,","\t\t\t\t\t $8,","\t\t\t\t\t -1","\t\t\t\t\t);","\t\t\t  delete($2);","\t\t\t}","\t\t|\tIDENTIFIER","\t\t\tASSIGN","\t\t\texpression","\t\t\t{","\t\t\t  $$\t= new AssignmentNode(new VariableNode(*$1),$3);","\t\t\t  delete($1);","\t\t\t}","\t\t|\tWRITELN","\t\t\t{","\t\t\t  $$\t= new WriteNode(true);","\t\t\t}","\t\t|\tWRITE","\t\t\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= new WriteNode(false,$3);","\t\t\t};","\t\t|\tWRITELN","\t\t\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= new WriteNode(true,$3);","\t\t\t};","","expression :\t\tsimpleExpression","\t   \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tLESSER","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(LESSER_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tLESSER_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(LESSER_EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tGREATER","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(GREATER_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tGREATER_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(GREATER_EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tEQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(EQUAL_CO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tNOT_EQUAL","\t\t\tsimpleExpression","\t\t\t{","\t\t\t  $$\t= new ComparisonOpNode(NOT_EQUAL_CO,$1,$3);","\t\t\t};","","simpleExpression :\tterm","\t   \t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tPLUS","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(ADD_BMO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tMINUS","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(SUBTRACT_BMO,$1,$3);","\t\t\t}","\t\t|\tsimpleExpression","\t\t\tOR","\t\t\tterm","\t\t\t{","\t\t\t  $$\t= new BinaryLogicOpNode(OR_BLO,$1,$3);","\t\t\t};","","term\t:\t\tfactor","\t\t\t{","\t\t\t  $$\t= $1;","\t\t\t}","\t\t|\tterm","\t\t\tSTAR","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(MULTIPLY_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tINT_DIV","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(INT_DIVIDE_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tREAL_DIV","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryMathOpNode(REAL_DIVIDE_BMO,$1,$3);","\t\t\t}","\t\t|\tterm","\t\t\tAND","\t\t\tfactor","\t\t\t{","\t\t\t  $$\t= new BinaryLogicOpNode(AND_BLO,$1,$3);","\t\t\t};","","factor :\t\tIDENTIFIER","       \t\t\t{","\t\t\t  $$\t= new VariableNode(*$1);","\t\t\t  delete($1);","\t\t\t}","\t\t|\tBOOLEAN","\t\t\t{","\t\t\t  $$\t= new BooleanConstantNode($1);","\t\t\t}","\t\t|\tINTEGER","\t\t\t{","\t\t\t  $$\t= new IntegerConstantNode($1);","\t\t\t}","\t\t|\tREAL","\t\t\t{","\t\t\t  $$\t= new RealConstantNode($1);","\t\t\t}","\t\t|\tSTRING","\t\t\t{","\t\t\t  $$\t= new StringConstantNode($1);","\t\t\t}","\t\t|\tBEGIN_PAREN","\t\t\texpression","\t\t\tEND_PAREN","\t\t\t{","\t\t\t  $$\t= $2;","\t\t\t};","\t\t\t","","%%","","","","//  PURPOSE:  To hold the address of the root of the parse tree.","Node*\t\tprogramRoot\t= NULL;","","","int\t\tyyerror\t\t(const char*\tcPtr)","{","  printf(\"%s, sorry!\\n\",cPtr);","  return(0);","}","","","int\t\tyylex\t\t();","","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'binaryLogicOp_ty' value.","const char*\tbinaryLogicOpName[]","\t\t\t\t= { \"\",","\t\t\t\t    \"or\",","\t\t\t\t    \"and\"","\t\t\t\t  };","","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'binaryMathOp_ty' value.","const char*\tbinaryMathOpName[]","      \t\t\t\t= { \"\",","\t\t\t\t    \"add\",","\t\t\t\t    \"sub\",","\t\t\t\t    \"mul\",","\t\t\t\t    \"div\"","\t\t\t\t  };","","//  PURPOSE:  To hold the names of SPVM assembly language instructions that","//\timplement the operations of the corresponding 'comparisonOp_ty' value.","const char*\tcomparisonOpName[]","      \t\t\t\t= { \"\",","\t\t\t\t    \"lesser\",","\t\t\t\t    \"lesserEqual\",","\t\t\t\t    \"greater\",","\t\t\t\t    \"greaterEqual\",","\t\t\t\t    \"equal\",","\t\t\t\t    \"not_equal\"","\t\t\t\t  };","","//  PURPOSE:  To hold the names of boolean constants.","const char*\tbooleanConstName[]","\t\t\t\t= {\"false\", \"true\"};","","","//  PURPOSE:  To point to the stream to which output should be written","std::ofstream*\toutputStreamPtr\t= NULL;","","//  PURPOSE:  To hold the next label number to use:","int\t\tLabelMention::nextLabelId__","\t\t\t\t= 0;","","","//  PURPOSE:  To output '*toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const LabelMention*\ttoPrint","\t\t\t\t)","{","  os << LABEL_COMMON_PREFIX << toPrint->getId() << LABEL_COMMON_POSTFIX;","  return(os);","}","","","//  PURPOSE:  To output 'toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const LabelMention&\ttoPrint","\t\t\t\t)","{","  os << LABEL_COMMON_PREFIX << toPrint.getId() << LABEL_COMMON_POSTFIX;","  return(os);","}","","","//  PURPOSE:  To hold the next auto-generated variable number to use:","int\t\tVariableMention::nextAutoVarId__","\t\t\t\t= RETURN_VAR + 1;","","","//  PURPOSE:  To output '*toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const VariableMention*\ttoPrint","\t\t\t\t)","{","  os << VAR_PREFIX_CHAR << toPrint->getName();","  return(os);","}","","","//  PURPOSE:  To output 'toPrint' to 'os'.  Returns 'os'.","std::ostream&\toperator<<\t(std::ostream&\t\tos,","\t\t\t\t const VariableMention&\ttoPrint","\t\t\t\t)","{","  os << VAR_PREFIX_CHAR << toPrint.getName();","}","","","","//  PURPOSE:  To hold defintions of symbols (e.g. variables)","SymbolTable\tsymbolTable;","","","//  PURPOSE:  To release the resources of '*this'.  No parameters.  No return","//\tvalue.","Node::~Node\t\t\t()","\t\t\t\t{ }","","","//  PURPOSE:  To make '*this' mention the variable named 'cPtr'.","//  \tNo parameters.  No return value.","VariableMention::VariableMention(const char*\tcPtr","  \t\t\t\t) :","\t\t\t\tname_(NULL)","\t\t\t\t{","\t\t\t\t  std::stringstream\tstrm;","","\t\t\t\t  strm << symbolTable.getOffset(cPtr);","\t\t\t\t  name_\t= strm.str();","\t\t\t\t}","","//  PURPOSE:  To make '*this' mention the variable named 'newName'.","//  \tNo parameters.  No return value.","VariableMention::VariableMention(const std::string&\tnewName","\t\t\t\t) :","\t\t\t\tname_(newName)","\t\t\t\t{","\t\t\t\t  std::stringstream\tstrm;","","\t\t\t\t  strm << symbolTable.getOffset(newName);","\t\t\t\t  name_\t= strm.str();","\t\t\t\t}","","//  PURPOSE:  To do compile-time checks of '*this' node.  'simpleType' is","//  \tset to the type that the code generated by '*this' node returns (or","//\t to 'NO_TYPE_ST' if it does not return a value).  Returns the address","//\t of a VariableMention that the code generated by '*this' node updates","//\t(or 'NULL' if there is no such variable).","VariableMention*","\t\tVariableNode::compile","\t\t\t\t(simpleType_ty&\tsimpleType","\t\t\t\t)","{","  //  Set 'simpleType' to the type returned by 'symbolTable.getType()' when","  //\tyou give it the name of the variable.","  //  If this type is 'NO_TYPE_ST' then do:","  //","  //\tthrow \"Undeclared variable\";","  //","  //  otherwise, set 'varPtr_' to a new VariableMention for this variable","  //\t(just say 'new VariableMention(getName()') and return 'varPtr_'.","  simpleType = symbolTable.getType(name_);","  if (simpleType == NO_TYPE_ST){","  \tthrow(\"Undeclared variable\");","  }","  else {","  \tvarPtr_ = new VariableMention(getName());","  }","  \treturn (varPtr_);","  ","  \t\t// <-- change that NULL","}","","","int\t\tmain\t\t(int\t\targc,","\t\t\t\t char*\t\targv[]","\t\t\t\t)","{","  //  I.  Application validity check:","  if  (argc < 2)","  {","    fprintf(stderr,\"Usage:\\t%s <pascalProg> <assemblyOutFile>\\n\",argv[0]);","    exit(EXIT_FAILURE);","  }","","  //  II.  Parse and execute program:","  //  II.A.  Initialize files:","  const char*\tpascalFilepath\t= argv[1];","  const char*\tassemblyFilepath= argv[2];","  std::ofstream\toutput(assemblyFilepath);","","  outputStreamPtr\t= &output;","","  if  ( (yyin = fopen(pascalFilepath,\"r\")) == NULL )","  {","    fprintf(stderr,\"Error opening %s.\\n\",pascalFilepath);","    exit(EXIT_FAILURE);","  }","","  if  ( !output.is_open() )","  {","    fprintf(stderr,\"Error opening %s.\\n\",assemblyFilepath);","    fclose(yyin);","    exit(EXIT_FAILURE);","  }","","  //  II.B.  Attempt to parse and assemble 'filename':","  int\tstatus\t= EXIT_SUCCESS;","","  try","  {","    yyparse();","","    if  (programRoot != NULL)","    {","      simpleType_ty\tsimpleType;","      VariableMention*\tnodePtr\t= programRoot->compile(simpleType);","","      programRoot->writeAssembly(output);","","      if  (nodePtr == NULL)","        output << \"  load \" << RETURN_VAR_NAME","\t       << \",\"  << RETURN_VAR","\t       << std::endl;","      else","      {","        output << \"  copy \" << RETURN_VAR_NAME","\t       << \",\" << *nodePtr","\t       << std::endl;","      }","","      output << \"  stopWSuccess\" << std::endl;","    }","","  }","  catch  (const char* cPtr)","  {","    fprintf(stderr,\"Error: %s\\n\",cPtr);","    status\t= EXIT_FAILURE;","  }","","  //  II.C.  Clean up:","  delete(programRoot);","  output.close();","  fclose(yyin);","","  //  III.  Finished:","  return(status);","}"]}]]},"ace":{"folds":[],"scrolltop":2357.5,"scrollleft":0,"selection":{"start":{"row":596,"column":5},"end":{"row":596,"column":5},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1511366372267,"hash":"ae11fbff20bf9c42dc518d11089cde2904194b44"}