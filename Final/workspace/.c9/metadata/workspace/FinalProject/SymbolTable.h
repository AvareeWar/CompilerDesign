{"changed":true,"filter":false,"title":"SymbolTable.h","tooltip":"/FinalProject/SymbolTable.h","value":"/*-------------------------------------------------------------------------*\n *---\t\t\t\t\t\t\t\t\t---*\n *---\t\tSymbolTable.h\t\t\t\t\t\t---*\n *---\t\t\t\t\t\t\t\t\t---*\n *---\t    This file declares and defines a class that represents\t---*\n *---\tthe symbol table of the tiny Pascal compiler.\t\t\t---*\n *---\t\t\t\t\t\t\t\t\t---*\n *---\t----\t----\t----\t----\t----\t----\t----\t----\t---*\n *---\t\t\t\t\t\t\t\t\t---*\n *---\tVersion 1a\t\t2017 June 2\t\tJoseph Phillips\t---*\n *---\t\t\t\t\t\t\t\t\t---*\n *-------------------------------------------------------------------------*/\n\nclass\t\tSymbolTable\n{\n  //  I.  Member vars:\n  //  PURPOSE:  To keep track of which the types of declared variables.\n  std::map<std::string,simpleType_ty>\n\t\t\t\tvarToTypeMap_;\n\n  //  PURPOSE:  To keep track of the variable number (the stack offset) of\n  //  \tdeclared variables.\n  std::map<std::string,int>\tvarToOffsetMap_;\n\n  //  II.  Disallowed auto-generated methods:\n  //  No copy constructor:\n  SymbolTable\t\t\t(const SymbolTable&\n\t\t\t\t);\n\n  //  No copy assignment op:\n  SymbolTable&\toperator=\t(const SymbolTable&\n\t\t\t\t);\n\nprotected :\n  //  III.  Protected methods:\n\npublic :\n  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:\n  //  PURPOSE:  To '*this' into make an initially empty SymbolTable.\n  SymbolTable\t\t\t()\n  \t\t\t\t{ }\n\n  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No\n  //\treturn value.\n  ~SymbolTable\t\t\t()\n  \t\t\t\t{ }\n\n  //  V.  Accessors:\n\n  //  VI.  Mutators:\n\n  //  VII.  Methods that do main and misc. work of class:\n  //  PURPOSE:  To declare a variable named 'newName' of type 'newType'.\n  //\tThrows exception as C-string if an existing variable already has\n  //\tname 'newName'.  No return value.\n  void\t\tdeclare\t\t(const std::string&\tnewName,\n  \t\t\t\t simpleType_ty\t\tnewType\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t  if  (varToTypeMap_.find(newName) !=\n\t\t\t\t       varToTypeMap_.end()\n\t\t\t\t      )\n\t\t\t\t    throw \"Attempt to redeclare variable\";\n\n\t\t\t\t  varToTypeMap_[newName]\n\t\t\t\t\t= newType;\n\t\t\t\t  varToOffsetMap_[newName]\n\t\t\t\t\t= VariableMention::getNextOffset();\n\n\t\t\t\t  *outputStreamPtr\n\t\t\t\t\t<< COMMENT_CHAR << \" Variable: \"\n\t\t\t\t\t<< newName << \"\\tOffset: \"\n\t\t\t\t\t<< varToOffsetMap_[newName]\n\t\t\t\t\t<< std::endl;\n\t\t\t\t}\n\n  //  PURPOSE:  To return the type previously given to the variable with name\n  //\tname 'name'.  Returns 'NO_TYPE_ST' if no such variable was\n  //\tdeclared.\n  simpleType_ty\tgetType\t\t(const std::string&\tname\n\t\t\t\t)\n\t\t\t\tconst\n\t\t\t\t{\n\t\t\t\t  std::map<std::string,simpleType_ty>::\n\t\t\t\t    const_iterator\n\t\t\t\t\titer\t= varToTypeMap_.find(name);\n\n\t\t\t\t  if  (iter == varToTypeMap_.end())\n\t\t\t\t    return(NO_TYPE_ST);\n\n\t\t\t\t  return(iter->second);\n\t\t\t\t}\n\n  //  PURPOSE:  To return the offset of the variable named 'name'.\n  int \t\tgetOffset\t(const std::string&  name\n\t\t\t\t)\n\t\t\t\tconst\n\t\t\t\t{\n\t\t\t\t  std::map<std::string,int>::const_iterator\n\t\t\t\t\titer\t= varToOffsetMap_.find(name);\n\n\t\t\t\t  if  (iter == varToOffsetMap_.end())\n\t\t\t\t    throw \"Attempt to use undeclared variable\";\n\n\t\t\t\t  return(iter->second);\n\t\t\t\t}\n};","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":106,"column":2},"action":"insert","lines":["/*-------------------------------------------------------------------------*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t\tSymbolTable.h\t\t\t\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t    This file declares and defines a class that represents\t---*"," *---\tthe symbol table of the tiny Pascal compiler.\t\t\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\t----\t----\t----\t----\t----\t----\t----\t----\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *---\tVersion 1a\t\t2017 June 2\t\tJoseph Phillips\t---*"," *---\t\t\t\t\t\t\t\t\t---*"," *-------------------------------------------------------------------------*/","","class\t\tSymbolTable","{","  //  I.  Member vars:","  //  PURPOSE:  To keep track of which the types of declared variables.","  std::map<std::string,simpleType_ty>","\t\t\t\tvarToTypeMap_;","","  //  PURPOSE:  To keep track of the variable number (the stack offset) of","  //  \tdeclared variables.","  std::map<std::string,int>\tvarToOffsetMap_;","","  //  II.  Disallowed auto-generated methods:","  //  No copy constructor:","  SymbolTable\t\t\t(const SymbolTable&","\t\t\t\t);","","  //  No copy assignment op:","  SymbolTable&\toperator=\t(const SymbolTable&","\t\t\t\t);","","protected :","  //  III.  Protected methods:","","public :","  //  IV.  Constructor(s), assignment op(s), factory(s) and destructor:","  //  PURPOSE:  To '*this' into make an initially empty SymbolTable.","  SymbolTable\t\t\t()","  \t\t\t\t{ }","","  //  PURPOSE:  To release the resources of '*this'.  No parameters.  No","  //\treturn value.","  ~SymbolTable\t\t\t()","  \t\t\t\t{ }","","  //  V.  Accessors:","","  //  VI.  Mutators:","","  //  VII.  Methods that do main and misc. work of class:","  //  PURPOSE:  To declare a variable named 'newName' of type 'newType'.","  //\tThrows exception as C-string if an existing variable already has","  //\tname 'newName'.  No return value.","  void\t\tdeclare\t\t(const std::string&\tnewName,","  \t\t\t\t simpleType_ty\t\tnewType","\t\t\t\t)","\t\t\t\t{","\t\t\t\t  if  (varToTypeMap_.find(newName) !=","\t\t\t\t       varToTypeMap_.end()","\t\t\t\t      )","\t\t\t\t    throw \"Attempt to redeclare variable\";","","\t\t\t\t  varToTypeMap_[newName]","\t\t\t\t\t= newType;","\t\t\t\t  varToOffsetMap_[newName]","\t\t\t\t\t= VariableMention::getNextOffset();","","\t\t\t\t  *outputStreamPtr","\t\t\t\t\t<< COMMENT_CHAR << \" Variable: \"","\t\t\t\t\t<< newName << \"\\tOffset: \"","\t\t\t\t\t<< varToOffsetMap_[newName]","\t\t\t\t\t<< std::endl;","\t\t\t\t}","","  //  PURPOSE:  To return the type previously given to the variable with name","  //\tname 'name'.  Returns 'NO_TYPE_ST' if no such variable was","  //\tdeclared.","  simpleType_ty\tgetType\t\t(const std::string&\tname","\t\t\t\t)","\t\t\t\tconst","\t\t\t\t{","\t\t\t\t  std::map<std::string,simpleType_ty>::","\t\t\t\t    const_iterator","\t\t\t\t\titer\t= varToTypeMap_.find(name);","","\t\t\t\t  if  (iter == varToTypeMap_.end())","\t\t\t\t    return(NO_TYPE_ST);","","\t\t\t\t  return(iter->second);","\t\t\t\t}","","  //  PURPOSE:  To return the offset of the variable named 'name'.","  int \t\tgetOffset\t(const std::string&  name","\t\t\t\t)","\t\t\t\tconst","\t\t\t\t{","\t\t\t\t  std::map<std::string,int>::const_iterator","\t\t\t\t\titer\t= varToOffsetMap_.find(name);","","\t\t\t\t  if  (iter == varToOffsetMap_.end())","\t\t\t\t    throw \"Attempt to use undeclared variable\";","","\t\t\t\t  return(iter->second);","\t\t\t\t}","};"],"id":1}]]},"ace":{"folds":[],"scrolltop":1163,"scrollleft":0,"selection":{"start":{"row":96,"column":9},"end":{"row":96,"column":9},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1511318611608}